# FastAPI Backend Integration with Better Auth JWT

Complete guide for integrating Better Auth JWT token validation in FastAPI backends.

## Overview

Better Auth manages sessions on the Next.js frontend. For FastAPI backend authentication, validate JWT tokens generated by the frontend token endpoint.

**Authentication Flow**:
1. Frontend verifies Better Auth session
2. Frontend generates JWT token signed with `BETTER_AUTH_SECRET`
3. Frontend includes JWT in `Authorization: Bearer <token>` header
4. Backend validates JWT signature and claims
5. Backend extracts user ID and scopes queries

## Installation

Install required dependencies:

```bash
# Using UV (recommended for this project)
cd backend
uv add "python-jose[cryptography]" python-multipart

# Or using pip
pip install "python-jose[cryptography]" python-multipart
```

## Environment Configuration

Add to `.env`:

```env
# Must match frontend BETTER_AUTH_SECRET exactly
BETTER_AUTH_SECRET=<same-secret-as-frontend>

# Token lifetime validation (optional)
ACCESS_TOKEN_EXPIRE_MINUTES=30
```

## JWT Validation Implementation

### 1. Security Module

Create `core/security.py`:

```python
import os
import time
from typing import Dict, Optional
from jose import jwt, JWTError
from fastapi import HTTPException, Request, status

# Configuration
SECRET_KEY = os.getenv("BETTER_AUTH_SECRET")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))

# Validate secret at startup
if not SECRET_KEY or len(SECRET_KEY) < 32:
    raise ValueError("BETTER_AUTH_SECRET must be at least 32 characters")


def verify_better_auth_token(token: str) -> Dict[str, any]:
    """
    Verify and decode Better Auth JWT token.

    Args:
        token: JWT token from Authorization header

    Returns:
        Decoded token payload with user claims

    Raises:
        HTTPException: If token is invalid or expired
    """
    try:
        # Decode JWT
        payload = jwt.decode(
            token,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Validate required claims
        user_id: str = payload.get("sub")
        email: str = payload.get("email")
        exp: int = payload.get("exp")
        iat: int = payload.get("iat")

        if not user_id or not email:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user claims"
            )

        # Validate expiration
        current_time = time.time()
        if exp and exp < current_time:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token expired"
            )

        # Validate token lifetime (15-30 minutes)
        if iat and exp:
            lifetime = exp - iat
            if lifetime < 900 or lifetime > 1800:  # 15-30 minutes
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid token lifetime"
                )

        return payload

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid token: {str(e)}"
        )


async def validate_path_user_id(request: Request, path_user_id: str) -> Dict[str, any]:
    """
    Validate that path user_id matches JWT token user_id.

    Args:
        request: FastAPI request object
        path_user_id: User ID from URL path parameter

    Returns:
        Decoded JWT payload

    Raises:
        HTTPException: If user_id mismatch or auth fails
    """
    # Extract token from Authorization header
    auth_header = request.headers.get("Authorization")

    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing or invalid Authorization header"
        )

    token = auth_header.replace("Bearer ", "")

    # Verify JWT
    payload = verify_better_auth_token(token)

    # Validate path user_id matches JWT user_id
    jwt_user_id = payload.get("sub")

    if jwt_user_id != path_user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User ID in path does not match authenticated user"
        )

    return payload
```

### 2. FastAPI Dependency

Create dependency for route protection:

```python
# core/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from core.security import verify_better_auth_token

security = HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict[str, any]:
    """
    FastAPI dependency to get current authenticated user.

    Usage:
        @router.get("/protected")
        async def protected_route(user=Depends(get_current_user)):
            return {"user_id": user["sub"]}
    """
    return verify_better_auth_token(credentials.credentials)
```

### 3. Protected Route Examples

```python
# routers/tasks.py
from fastapi import APIRouter, Depends, Request
from core.security import validate_path_user_id
from core.dependencies import get_current_user

router = APIRouter(prefix="/api/v1", tags=["tasks"])


@router.get("/{user_id}/tasks")
async def list_tasks(
    user_id: str,
    request: Request,
):
    """
    List tasks for authenticated user.

    Three-layer security:
    1. Valid JWT token (checked by validate_path_user_id)
    2. Path user_id matches JWT user_id
    3. Database query scoped to authenticated user
    """
    # Validate path user_id matches JWT user_id
    payload = await validate_path_user_id(request, user_id)
    authenticated_user_id = payload["sub"]

    # Query database using JWT user_id (NOT path parameter)
    tasks = await get_user_tasks(authenticated_user_id)

    return {"tasks": tasks}


@router.post("/{user_id}/tasks")
async def create_task(
    user_id: str,
    request: Request,
    task_data: TaskCreate,
):
    """Create task for authenticated user."""
    payload = await validate_path_user_id(request, user_id)
    authenticated_user_id = payload["sub"]

    # Create task with authenticated user_id
    task = await create_user_task(authenticated_user_id, task_data)

    return {"task": task}


# Alternative: Simple protection without path validation
@router.get("/me/profile")
async def get_profile(user = Depends(get_current_user)):
    """Get current user profile."""
    user_id = user["sub"]
    email = user["email"]
    name = user["name"]

    return {
        "id": user_id,
        "email": email,
        "name": name,
    }
```

## Multi-Layer Security

### Layer 1: JWT Authentication

Validate JWT token signature and expiration:

```python
# Happens in verify_better_auth_token()
payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
```

### Layer 2: Path Validation

Ensure path `user_id` matches JWT `sub` claim:

```python
# Prevents users from accessing other users' data
if jwt_user_id != path_user_id:
    raise HTTPException(status_code=403, detail="Forbidden")
```

### Layer 3: Query Filtering

Scope all database queries to authenticated user:

```python
# ALWAYS use JWT user_id, NEVER use path parameter
tasks = await db.execute(
    select(Task).where(Task.user_id == authenticated_user_id)
)
```

## Error Handling

### Standard Error Responses

```python
# 401 Unauthorized - Invalid/expired token
{
  "detail": "Token expired"
}

# 403 Forbidden - User ID mismatch
{
  "detail": "User ID in path does not match authenticated user"
}

# 422 Unprocessable Entity - Invalid request data
{
  "detail": [
    {
      "loc": ["body", "title"],
      "msg": "field required",
      "type": "value_error.missing"
    }
  ]
}
```

### Custom Exception Handlers

```python
# main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from jose import JWTError

app = FastAPI()


@app.exception_handler(JWTError)
async def jwt_exception_handler(request: Request, exc: JWTError):
    return JSONResponse(
        status_code=401,
        content={"detail": "Invalid authentication credentials"}
    )
```

## CORS Configuration

Configure CORS for Next.js frontend:

```python
# main.py
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # Development
        os.getenv("FRONTEND_URL", ""),  # Production
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## Testing

### Unit Test Example

```python
# tests/test_security.py
import pytest
from jose import jwt
from core.security import verify_better_auth_token
import time

SECRET_KEY = "test-secret-key-min-32-characters-long"


def test_valid_token():
    """Test validation of valid JWT token."""
    payload = {
        "sub": "user123",
        "email": "test@example.com",
        "name": "Test User",
        "exp": int(time.time()) + 1800,  # 30 minutes
        "iat": int(time.time()),
        "type": "access",
    }

    token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
    decoded = verify_better_auth_token(token)

    assert decoded["sub"] == "user123"
    assert decoded["email"] == "test@example.com"


def test_expired_token():
    """Test rejection of expired token."""
    payload = {
        "sub": "user123",
        "email": "test@example.com",
        "exp": int(time.time()) - 100,  # Expired
        "iat": int(time.time()) - 1900,
    }

    token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")

    with pytest.raises(HTTPException) as exc_info:
        verify_better_auth_token(token)

    assert exc_info.value.status_code == 401
    assert "expired" in str(exc_info.value.detail).lower()
```

### Integration Test Example

```python
# tests/test_routes.py
from fastapi.testclient import TestClient
from main import app
import jwt
import time

client = TestClient(app)
SECRET_KEY = "test-secret-key-min-32-characters-long"


def create_test_token(user_id: str = "test-user") -> str:
    """Create valid JWT token for testing."""
    payload = {
        "sub": user_id,
        "email": "test@example.com",
        "name": "Test User",
        "exp": int(time.time()) + 1800,
        "iat": int(time.time()),
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")


def test_protected_route_with_valid_token():
    """Test accessing protected route with valid token."""
    token = create_test_token("user123")

    response = client.get(
        "/api/v1/user123/tasks",
        headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == 200


def test_protected_route_without_token():
    """Test accessing protected route without token."""
    response = client.get("/api/v1/user123/tasks")

    assert response.status_code == 401


def test_path_user_id_mismatch():
    """Test that user cannot access other user's data."""
    token = create_test_token("user123")

    # Try to access user456's data with user123's token
    response = client.get(
        "/api/v1/user456/tasks",
        headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == 403
```

## Best Practices

1. **Always Use JWT User ID for Queries**
   - Extract `user_id` from `payload["sub"]`
   - Never trust path parameters for authorization
   - Validate path matches JWT for API consistency

2. **Validate Token Lifetime**
   - Enforce 15-30 minute expiration
   - Reject tokens with suspicious lifetimes
   - Log unusual expiration patterns

3. **Secure Secret Management**
   - Use same `BETTER_AUTH_SECRET` as frontend
   - Minimum 32 characters
   - Never log or expose secret
   - Rotate periodically

4. **Error Handling**
   - Return 401 for authentication failures
   - Return 403 for authorization failures
   - Don't leak sensitive information in errors
   - Log security events for monitoring

5. **Testing**
   - Test valid tokens
   - Test expired tokens
   - Test missing tokens
   - Test user_id mismatches
   - Test token tampering

## Next Steps

- Implement API client with token attachment (see `api-client.md`)
- Review security best practices (see `security-patterns.md`)
- Set up troubleshooting procedures (see `troubleshooting.md`)
