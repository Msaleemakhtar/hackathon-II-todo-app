<!--
SYNC IMPACT REPORT:
Version Change: 2.1.1 -> 2.2.0
Amendment Date: 2025-12-09

Modified Principles:
  - I. Spec-Driven Development:
    * CHANGED: "Exception for AI Limitations" rule relaxed from rigid "three refinement cycles"
      to flexible "reasonable refinement efforts" while maintaining strict documentation requirements
    * RATIONALE: Rigid cycle count was impractical; quality of refinement matters more than count

  - IV. User Authentication & JWT Security:
    * CHANGED: "Authentication Flow" clarified that frontend sends credentials but backend is
      solely responsible for authenticating users and issuing JWTs
    * CHANGED: "Security Standards" - removed "optional" status from refresh token rotation and
      token blacklisting; explicitly marked as OUT OF SCOPE for Phase II with future target
    * ADDED: "Backend Validation" enhanced with explicit user ID path parameter matching requirement
      for APIs with user ID in path (e.g., /users/{user_id}/tasks)
    * RATIONALE: Clarifies architectural responsibilities and eliminates security ambiguity

  - IX. CI/CD Pipeline:
    * CHANGED: "PR Checks" quality gates restructured - strict coverage and performance thresholds
      moved to non-blocking "Nightly Pipeline" for main branch health reporting
    * ADDED: PR coverage rule changed to "must not decrease overall coverage percentage"
    * RATIONALE: Expensive checks on every PR slowed development; nightly checks maintain standards
      without blocking iteration

Templates Requiring Updates:
  - None identified - changes are governance/clarification focused

Follow-up TODOs:
  - Create GitHub Actions workflow for Nightly Pipeline (coverage >= 80%, Lighthouse >= 90)
  - Consider ADR for CI/CD pipeline restructuring decision
  - Update any existing spec files referencing "three refinement cycles" if present
-->

# Todo App - Phase II Constitution

## Mission Statement

Evolve the CLI application into a feature-rich, multi-user, full-stack web application with persistent storage. Establish a scalable, secure, modern architecture for a cloud-native, distributed system while strictly adhering to Spec-Driven Development principles.

---

## Core Principles

### I. Spec-Driven Development (Mandatory)

**Philosophy**: The specification is the single source of truth; AI is the implementation engine.

**Requirements**:
- ALL frontend and backend code MUST be generated by an AI agent from written specifications in the `/specs` directory.
- Manual coding of features, business logic, UI components, or API endpoints is **strictly forbidden**, with one documented exception.
- **Exception for AI Limitations**: In the rare event that the AI code generator cannot produce a correct implementation for a well-defined specification after reasonable refinement efforts (iterating on prompts, breaking down complexity, adjusting specification clarity), a developer may manually write the minimum necessary code. This action MUST be:
  1. Documented in `DEVIATIONS.md` with full justification including refinement attempts made
  2. Reviewed by the team before merging
  3. Tagged with `[AI-LIMITATION]` in commit message
  4. Accompanied by the specification that was attempted
- Development follows the cycle: **Spec --> AI Generate --> Test --> Refine Spec --> Regenerate**.
- Specifications MUST be managed via GitHub Spec-Kit Plus in the `/specs` directory.
- Spec organization MUST follow the default Specify Plus Kit structure: `/specs/NNN-feature-name/` where each feature directory contains `spec.md`, `plan.md`, `tasks.md`, and related artifacts.

**Verification**:
- Commit history shows specification files created/modified before implementation files.
- Pull request descriptions reference the spec file(s) that drive the implementation.
- No implementation PRs without corresponding spec file changes or references.

**Rationale**: AI-driven development ensures consistency, reduces human error, maintains clear traceability from specification to implementation, and demonstrates the viability of AI-first software engineering at scale.

---

### II. Full-Stack Monorepo Architecture

**Philosophy**: Unified codebase with clear separation of concerns.

**Requirements**:
- **Repository Structure**: Monorepo with distinct directories:
  - `/frontend` - Next.js 16 (App Router) application
  - `/backend` - Python FastAPI server
  - `/packages` - Shared code (TypeScript types, SDKs, utilities)
  - `/specs` - All specifications (features, api, database, ui)
- **Frontend Technology**:
  - Next.js 16 with App Router (NOT Pages Router)
  - TypeScript with strict mode enabled
  - shadcn/ui component library
  - Tailwind CSS for styling
  - Zustand for global state management
  - axios for HTTP client with interceptors
- **Backend Technology**:
  - Python 3.11+ with FastAPI framework
  - SQLModel for ORM and data validation
  - Pydantic for input/output schemas
  - asyncpg driver for async PostgreSQL access
  - Alembic for database migrations
- **Package Management**:
  - `bun` for frontend dependencies AND workspace management
  - `uv` for backend Python dependencies
  - NO npm or yarn for frontend
  - NO pip or poetry for backend

**Directory Standards**:
```
/
├── frontend/
│   ├── src/
│   │   ├── app/           # Next.js App Router pages
│   │   ├── components/    # Reusable UI components
│   │   ├── lib/           # Utilities, API client, stores
│   │   └── types/         # TypeScript type definitions
│   ├── public/
│   └── package.json
├── backend/
│   ├── src/
│   │   ├── routers/       # APIRouter modules
│   │   ├── models/        # SQLModel entities
│   │   ├── schemas/       # Pydantic schemas
│   │   ├── services/      # Business logic
│   │   └── core/          # Config, dependencies, security
│   ├── tests/
│   ├── alembic/
│   └── pyproject.toml
├── packages/
│   └── auth-sdk/      # Shared TypeScript definitions, SDKs, etc.
├── specs/
│   ├── 001-feature-name/  # Feature-specific directory
│   │   ├── spec.md        # Feature specification
│   │   ├── plan.md        # Implementation plan
│   │   ├── tasks.md       # Task breakdown
│   │   └── ...            # Additional artifacts (ADRs, PHRs, etc.)
│   └── 002-another-feature/
└── docker-compose.yml
```

**Rationale**: Monorepo enables atomic changes across frontend and backend, shared type definitions, unified CI/CD, and simplified dependency management while maintaining clear architectural boundaries.

---

### III. Persistent & Relational State

**Philosophy**: Production-grade persistence with cloud-native infrastructure.

**Requirements**:
- **Database**: Neon Serverless PostgreSQL as the single source of truth.
- **ORM**: SQLModel MUST be used for all data access (combines SQLAlchemy and Pydantic).
- **Async Access**: All database operations MUST use asyncpg driver for non-blocking I/O.
- **Migrations**: Schema changes MUST be managed via Alembic migrations:
  - Every schema change requires a migration file
  - Migrations MUST be reversible (include upgrade AND downgrade)
  - Migration naming: `YYYYMMDD_HHMMSS_descriptive_name.py`
- **Connection Pooling**: Production deployments MUST use connection pooling.
- **Data Isolation**: ALL database queries MUST scope to the authenticated user's ID.

**Verification**:
- No raw SQL queries outside of migrations
- All queries include user_id filter (enforced via FastAPI dependencies)
- Alembic migration history matches production schema
- Database connection uses async context managers

**Rationale**: Neon provides serverless PostgreSQL with automatic scaling, SQLModel provides type-safe data access, and Alembic ensures reproducible schema evolution across environments.

---

### IV. User Authentication & JWT Security (The JWT Challenge)

**Philosophy**: Secure, stateless authentication with defense-in-depth token management.

**Requirements**:

**Authentication Flow**:
1. **Frontend Auth**: Better Auth library handles user signup/login UI on Next.js frontend. Frontend collects and sends user credentials to the backend.
2. **Token Issuance**: Backend is solely responsible for authenticating users and issuing JWT tokens. Frontend MUST NOT issue, sign, or generate JWTs. Upon successful authentication, backend issues:
   - Access Token: 15-minute expiry, contains user ID and roles
   - Refresh Token: 7-day expiry, used only for token refresh
3. **Token Management**: Frontend receives tokens from backend and manages their storage and attachment to requests. Frontend only receives and manages tokens; it never creates them.
4. **Token Attachment**: Frontend axios interceptor attaches access token to `Authorization: Bearer <token>` header on all protected requests.
5. **Token Refresh Flow**:
   - axios interceptor detects 401 Unauthorized response
   - Interceptor calls `/auth/refresh` with refresh token
   - New access token received and stored
   - Original request retried with new token
   - If refresh fails, redirect to login
6. **Backend Validation**: FastAPI dependency validates access token on all protected endpoints:
   - Verify signature with secret key
   - Check expiration
   - Extract user_id from payload
   - **Path Parameter Matching**: When user ID appears in the API path (e.g., `/api/v1/users/{user_id}/tasks`), the backend MUST compare the `user_id` extracted from the validated JWT against the `user_id` path parameter. If they do not match, return 403 Forbidden. This prevents users from accessing other users' resources even with a valid token.
7. **Data Scoping**: User ID from JWT payload MUST scope ALL database queries.
8. **Secure Storage**:
   - Refresh tokens stored in HttpOnly, Secure, SameSite=Strict cookies
   - Access tokens stored in memory only (NOT localStorage)

**JWT Token Structure**:
```json
{
  "sub": "<user_id>",
  "email": "<user_email>",
  "exp": "<expiration_timestamp>",
  "iat": "<issued_at_timestamp>",
  "type": "access|refresh"
}
```

**Security Standards**:
- MUST use RS256 or HS256 algorithm (RS256 preferred for production)
- Secret keys MUST be at least 256 bits
- Rate limiting on auth endpoints: 5 attempts per minute per IP

**Phase II Scope Boundaries**:
The following security features are explicitly OUT OF SCOPE for Phase II and targeted for future implementation:
- **Refresh token rotation**: Rotating refresh tokens on each use (Phase III target)
- **Token blacklisting**: Server-side token revocation for logout (Phase III target)

**Rationale**: These features add complexity that exceeds Phase II scope. The current implementation provides adequate security for the MVP while clearly identifying enhancement paths.

**Verification**:
- All protected routes return 401 without valid token
- Expired tokens return 401 and trigger refresh flow
- Refresh tokens cannot be used as access tokens
- User A cannot access User B's data (data isolation test)
- Path parameter user ID mismatches return 403 Forbidden

**Rationale**: Short-lived access tokens limit damage from token theft, refresh tokens enable seamless UX, and proper token storage prevents XSS/CSRF attacks. Backend-only JWT issuance ensures cryptographic operations remain server-side where secrets can be properly protected.

---

### V. Backend Architecture Standards

**Philosophy**: Clean, testable, and maintainable API design.

**Requirements**:

**Router Organization**:
- Endpoints organized in `/backend/src/routers/` using FastAPI APIRouter
- One router file per resource domain (e.g., `tasks.py`, `auth.py`, `tags.py`)
- Routers registered in `main.py` with version prefix

**API Versioning**:
- ALL routes prefixed with `/api/v1/`
- Version changes require new router files (e.g., `/api/v2/tasks`)
- Breaking changes MUST increment API version

**Configuration**:
- pydantic-settings for environment-based configuration
- `.env` files for local development (NEVER committed)
- Environment variables for production secrets
- `Settings` class validates all config on startup

**Documentation**:
- FastAPI automatic OpenAPI documentation MUST be enabled
- Swagger UI available at `/docs`
- ReDoc available at `/redoc`
- All endpoints MUST have docstrings describing behavior

**Security**:
- CORS policy MUST restrict to deployed frontend domain only
- Local development may allow localhost origins
- All inputs validated via Pydantic models
- SQL injection prevented via SQLModel parameterization
- Rate limiting on sensitive endpoints

**Error Handling**:
- Consistent error response format:
  ```json
  {
    "detail": "Human-readable message",
    "code": "ERROR_CODE",
    "field": "optional_field_name"
  }
  ```
- Standard HTTP status codes (400, 401, 403, 404, 422, 500)
- No stack traces in production responses

**Logging**:
- Structured JSON logging in production
- Request ID tracking across services
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL

**Pre-commit Hooks**:
- `ruff check` - linting MUST pass
- `ruff format` - formatting MUST pass
- `pip-audit` - security vulnerability check

**Rationale**: Consistent API design enables frontend predictability, proper error handling improves debugging, and pre-commit hooks catch issues before they enter the codebase.

---

### VI. Frontend Architecture Standards

**Philosophy**: Fast, accessible, and delightful user experience.

**Requirements**:

**Component Structure**:
- Feature-based or type-based organization (choose one, be consistent)
- Feature-based example: `/components/tasks/TaskCard.tsx`
- Type-based example: `/components/ui/Button.tsx`
- shadcn/ui components in `/components/ui/`

**State Management**:
- Zustand for global state (auth state, user preferences)
- React Query or SWR for server state (tasks, tags)
- Local component state for UI-only state

**Environment Variables**:
- `NEXT_PUBLIC_` prefix for browser-exposed variables
- Server-only variables for API keys and secrets
- Type-safe env access via zod validation

**User Experience Standards**:
- **Optimistic UI Updates**: UI updates immediately, reverts on server error
- **Skeleton Loading States**: Show content placeholders during data fetch
- **Toast Notifications**: Non-blocking feedback for actions (success, error)
- **Input Debouncing**: 300ms debounce on search inputs
- **Error Boundaries**: Graceful error handling with recovery options
- **Responsive Design**: Mobile-first, works on all screen sizes

**Accessibility Standards**:
- ARIA labels on interactive elements
- Keyboard navigation support
- Color contrast meets WCAG AA
- Focus management for modals and dialogs

**Performance Standards**:
- First Contentful Paint < 1.5s
- Time to Interactive < 3s
- Bundle size monitoring in CI

**Rationale**: Consistent UX patterns reduce user frustration, optimistic updates feel instant, and accessibility ensures the app works for everyone.

---

### VII. Automated Testing Standards

**Philosophy**: Comprehensive testing enables confident refactoring and continuous deployment.

**Backend Testing Requirements**:
- **Framework**: pytest with pytest-asyncio for async tests
- **Database Isolation**: testcontainers for isolated PostgreSQL per test suite
- **Test Categories**:
  - Unit tests: Business logic in `/services/`
  - Integration tests: API endpoints with database
  - Contract tests: API schema validation
- **Coverage**: Minimum 80% code coverage on core logic
- **Execution**: `cd backend && uv run pytest`

**Frontend Testing Requirements**:
- **Framework**: Vitest (or Jest) with React Testing Library
- **Test Categories**:
  - Unit tests: Utility functions, hooks
  - Component tests: Isolated component behavior
  - Integration tests: User flows with MSW mocking
- **Coverage**: Minimum 70% code coverage on components
- **Execution**: `cd frontend && bun test`

**End-to-End Testing (Optional)**:
- Playwright for critical user journeys
- Run in CI on staging deployments

**Test Naming Convention**:
- `test_<action>_<condition>_<expected_result>`
- Example: `test_create_task_with_empty_title_returns_400`

**Verification**:
- All tests pass before merge (enforced in CI)
- Coverage reports generated and tracked
- No skipped tests without justification comment

**Rationale**: Comprehensive testing catches regressions, enables refactoring, and provides documentation of expected behavior.

---

### VIII. Containerization & Deployment

**Philosophy**: Environment parity from development to production.

**Requirements**:

**Docker Configuration**:
- `Dockerfile` in `/frontend` for Next.js production build
- `Dockerfile` in `/backend` for FastAPI production build
- `docker-compose.yml` at root for local development environment
- Multi-stage builds to minimize image size

**Local Development**:
- `docker-compose up` starts all services (frontend, backend, database)
- Hot-reload enabled for both frontend and backend
- Local PostgreSQL or Neon dev branch for database

**Environment Management**:
- Development: Local Docker Compose or direct processes
- Staging: Auto-deploy from main branch
- Production: Deploy from tagged releases

**Health Checks**:
- Backend: `/health` endpoint returns service status
- Frontend: Next.js built-in health checks
- Database: Connection verification on startup

**Rationale**: Docker ensures consistent environments, reduces "works on my machine" issues, and simplifies deployment pipeline.

---

### IX. CI/CD Pipeline

**Philosophy**: Automated quality gates and deployment with practical iteration speed.

**Requirements**:

**GitHub Actions Workflows**:

**PR Checks** (on pull_request) - Fast feedback for developers:
- Lint frontend: `bun run lint`
- Lint backend: `ruff check .`
- Test frontend: `bun test`
- Test backend: `uv run pytest`
- Build frontend: `bun run build`
- Type check frontend: `bun run typecheck`
- **Coverage Gate**: PR MUST NOT decrease overall test coverage percentage (compare against main branch baseline)

**Nightly Pipeline** (scheduled, runs on main branch) - Comprehensive health checks:
- All PR checks
- **Coverage Threshold Check**: Backend coverage >= 80%, Frontend coverage >= 70%
- **Performance Audit**: Lighthouse Performance score >= 90
- **Security Scan**: Dependency vulnerability audit
- **Report Generation**: Publish results to team dashboard/notifications
- **Non-blocking**: Failures generate alerts but do not block development

**Rationale for Pipeline Separation**: Expensive performance audits and strict threshold checks on every PR slow development velocity. Moving these to a nightly pipeline maintains quality standards while enabling faster iteration. PRs focus on not regressing quality; nightly checks ensure absolute thresholds are met.

**Staging Deploy** (on push to main):
- All PR checks pass
- Auto-deploy to staging environment
- Run smoke tests against staging

**Production Deploy** (on release tag):
- All checks pass
- Manual approval (optional)
- Deploy to production environment
- Tag docker images with version

**Branch Protection**:
- main branch requires PR
- PRs require passing CI checks
- PRs require at least 1 approval (if team > 1)

**Secrets Management**:
- GitHub Secrets for deployment credentials
- Rotate secrets quarterly
- Never commit secrets to repository

**Rationale**: CI/CD automation ensures consistent quality, prevents broken deployments, and enables rapid iteration while nightly checks maintain long-term code health.

---

### X. Feature Scope (Phase II)

**Philosophy**: Expand core functionality with user-centric features.

**Basic Features (Priority P1 - MVP)**:
1. **Add Task** - Create task with title, description, priority
2. **View Tasks** - Display paginated task list with status indicators
3. **Update Task** - Modify task title, description, priority, due date
4. **Delete Task** - Remove task with confirmation
5. **Mark Complete** - Toggle task completion status

**Intermediate Features (Priority P2)**:
6. **Priorities** - High, Medium, Low priority assignment
7. **Tags/Categories** - Create, assign, and manage task tags
8. **Search** - Full-text search across task titles and descriptions
9. **Filter** - Filter by status (all, pending, completed), priority, tag
10. **Sort** - Sort by due date, priority, creation date, title

**Advanced Features (Priority P3)**:
11. **Due Dates** - Set due dates with visual indicators
12. **Time Reminders** - Browser push notifications for due tasks
13. **Recurring Tasks** - iCal RRULE format for recurring schedules

**Explicitly Out of Scope for Phase II**:
- Team/organization features
- Task sharing or collaboration
- File attachments
- Subtasks or task dependencies
- Integrations with external services (calendar, email)
- Mobile native applications

**Rationale**: Prioritized feature scope ensures MVP delivery while planning for valuable enhancements without scope creep.

---

## Data Model Specification

### User Entity (SQLModel)

| Field      | Type   | Constraints                          | Description                         |
|------------|--------|--------------------------------------|-------------------------------------|
| id         | str    | PRIMARY KEY                          | User ID from Better Auth            |
| email      | str    | UNIQUE, NOT NULL                     | User's email address                |
| name       | str    | NULLABLE                             | User's display name                 |
| created_at | datetime | NOT NULL, DEFAULT now()            | Account creation timestamp          |

### Tag Entity (SQLModel)

| Field    | Type   | Constraints                          | Description                         |
|----------|--------|--------------------------------------|-------------------------------------|
| id       | int    | PRIMARY KEY, AUTOINCREMENT           | Unique tag identifier               |
| name     | str    | NOT NULL, max 50 chars               | Tag display name                    |
| color    | str    | NULLABLE, hex format                 | Tag color for UI display            |
| user_id  | str    | FOREIGN KEY -> User.id, NOT NULL     | Owner of the tag                    |

**Constraint**: UNIQUE(name, user_id) - No duplicate tag names per user

### Task Entity (SQLModel)

| Field           | Type         | Constraints                          | Description                         |
|-----------------|--------------|--------------------------------------|-------------------------------------|
| id              | int          | PRIMARY KEY, AUTOINCREMENT           | Unique task identifier              |
| title           | str          | NOT NULL, 1-200 chars                | Task title                          |
| description     | str          | NULLABLE, max 1000 chars             | Detailed description                |
| completed       | bool         | NOT NULL, DEFAULT False              | Completion status                   |
| priority        | str          | NOT NULL, DEFAULT 'medium'           | Enum: 'low', 'medium', 'high'       |
| due_date        | datetime     | NULLABLE                             | Task due date and time              |
| recurrence_rule | str          | NULLABLE                             | iCal RRULE string                   |
| user_id         | str          | FOREIGN KEY -> User.id, NOT NULL     | Task owner                          |
| created_at      | datetime     | NOT NULL, DEFAULT now()              | Creation timestamp                  |
| updated_at      | datetime     | NOT NULL, DEFAULT now(), ON UPDATE   | Last modification timestamp         |
| tags            | List[Tag]    | Many-to-Many via TaskTagLink         | Associated tags                     |

### TaskTagLink Entity (Junction Table)

| Field   | Type | Constraints                          | Description                         |
|---------|------|--------------------------------------|-------------------------------------|
| task_id | int  | FOREIGN KEY -> Task.id, PRIMARY KEY  | Task reference                      |
| tag_id  | int  | FOREIGN KEY -> Tag.id, PRIMARY KEY   | Tag reference                       |

**Constraint**: Composite PRIMARY KEY(task_id, tag_id)

### Database Indexes

- `idx_tasks_user_id` on tasks(user_id) - User task lookup
- `idx_tasks_user_completed` on tasks(user_id, completed) - Filtered task lists
- `idx_tasks_user_priority` on tasks(user_id, priority) - Priority sorting
- `idx_tasks_user_due_date` on tasks(user_id, due_date) - Due date sorting
- `idx_tags_user_id` on tags(user_id) - User tag lookup
- `idx_task_tag_link_task` on task_tag_link(task_id) - Tag lookup by task
- `idx_task_tag_link_tag` on task_tag_link(tag_id) - Task lookup by tag

---

## Validation Rules

### Task Title
- **Required**: Cannot be empty or whitespace-only
- **Length**: 1-200 characters after trimming
- **Error**: `{"detail": "Title is required and must be 1-200 characters", "code": "INVALID_TITLE"}`

### Task Description
- **Optional**: Can be null or empty string
- **Length**: Maximum 1000 characters
- **Error**: `{"detail": "Description cannot exceed 1000 characters", "code": "DESCRIPTION_TOO_LONG"}`

### Task Priority
- **Required**: Must be one of: 'low', 'medium', 'high'
- **Default**: 'medium'
- **Error**: `{"detail": "Priority must be low, medium, or high", "code": "INVALID_PRIORITY"}`

### Due Date
- **Optional**: Can be null
- **Format**: ISO 8601 datetime string
- **Constraint**: Cannot be in the past when creating (warning only on update)
- **Error**: `{"detail": "Due date must be a valid ISO 8601 datetime", "code": "INVALID_DUE_DATE"}`

### Recurrence Rule
- **Optional**: Can be null
- **Format**: Valid iCal RRULE string
- **Error**: `{"detail": "Recurrence rule must be a valid iCal RRULE", "code": "INVALID_RRULE"}`

### Tag Name
- **Required**: Cannot be empty or whitespace-only
- **Length**: 1-50 characters after trimming
- **Uniqueness**: No duplicate names per user
- **Error**: `{"detail": "Tag name is required and must be 1-50 characters", "code": "INVALID_TAG_NAME"}`

### Task ID (for operations)
- **Required**: Must be a valid integer
- **Existence**: Must correspond to an existing task owned by the user
- **Error**: `{"detail": "Task not found", "code": "TASK_NOT_FOUND"}`

---

## API Design Standards

### Endpoint Patterns

| Operation       | Method | Path                          | Success Code |
|-----------------|--------|-------------------------------|--------------|
| List resources  | GET    | /api/v1/{resources}           | 200          |
| Get resource    | GET    | /api/v1/{resources}/{id}      | 200          |
| Create resource | POST   | /api/v1/{resources}           | 201          |
| Update resource | PUT    | /api/v1/{resources}/{id}      | 200          |
| Partial update  | PATCH  | /api/v1/{resources}/{id}      | 200          |
| Delete resource | DELETE | /api/v1/{resources}/{id}      | 204          |

### Authentication Endpoints

| Operation       | Method | Path                          | Success Code |
|-----------------|--------|-------------------------------|--------------|
| Login           | POST   | /api/v1/auth/login            | 200          |
| Register        | POST   | /api/v1/auth/register         | 201          |
| Refresh token   | POST   | /api/v1/auth/refresh          | 200          |
| Logout          | POST   | /api/v1/auth/logout           | 200          |
| Current user    | GET    | /api/v1/auth/me               | 200          |

### Query Parameters

- `page`: Page number (default: 1)
- `limit`: Items per page (default: 20, max: 100)
- `sort`: Field to sort by (prefix with - for descending)
- `status`: Filter by status (all, pending, completed)
- `priority`: Filter by priority (low, medium, high)
- `tag`: Filter by tag ID or name
- `q`: Search query string

### Response Pagination Format

```json
{
  "items": [...],
  "total": 150,
  "page": 1,
  "limit": 20,
  "pages": 8
}
```

---

## Success Criteria (Phase II Completion)

### Functional Requirements
- [ ] **User Auth**: Users can register, login, logout, and refresh tokens
- [ ] **Task CRUD**: All basic task operations work correctly
- [ ] **Data Isolation**: Users only see their own tasks and tags
- [ ] **Priorities**: Tasks can be assigned and filtered by priority
- [ ] **Tags**: Users can create, edit, delete, and assign tags
- [ ] **Search**: Full-text search returns relevant results
- [ ] **Filter/Sort**: All filter and sort combinations work
- [ ] **Due Dates**: Tasks display due date indicators correctly
- [ ] **Notifications**: Browser notifications trigger for due tasks (P3)
- [ ] **Recurring Tasks**: RRULE parsing and next occurrence calculation (P3)

### Technical Requirements
- [ ] **AI-Generated Code**: All code generated from specs with exceptions documented
- [ ] **Backend Tests**: pytest coverage >= 80% on core logic (verified in nightly pipeline)
- [ ] **Frontend Tests**: Component test coverage >= 70% (verified in nightly pipeline)
- [ ] **CI Pipeline**: All PR checks pass (lint, test, build) on every PR
- [ ] **Docker**: Both services run via `docker-compose up`
- [ ] **API Docs**: OpenAPI documentation accurate and complete
- [ ] **JWT Security**: Token refresh flow works correctly
- [ ] **Performance**: Lighthouse score >= 90 (verified in nightly pipeline)

### Documentation Requirements
- [ ] Specs exist for all features in `/specs/NNN-feature-name/spec.md`
- [ ] Implementation plans exist in `/specs/NNN-feature-name/plan.md`
- [ ] Task breakdowns exist in `/specs/NNN-feature-name/tasks.md`
- [ ] README.md includes setup, development, and deployment instructions
- [ ] DEVIATIONS.md documents any manual code (if any)

---

## Constraints (Hard Limits)

### Development Constraints
- **No Manual Coding**: AI agent generates all implementation (see Principle I for exception)
- **Spec First**: No implementation without corresponding specification
- **Version Control**: All changes via pull requests to main

### Technology Constraints
- **Frontend**: Next.js 16 App Router, TypeScript, bun only
- **Backend**: Python 3.11+, FastAPI, uv only
- **Database**: PostgreSQL (Neon Serverless) only
- **ORM**: SQLModel only (no raw SQLAlchemy)

### Security Constraints
- **No Secrets in Code**: All secrets via environment variables
- **Token Storage**: Access tokens in memory, refresh in HttpOnly cookies
- **Data Access**: All queries scoped to authenticated user
- **Path Parameter Validation**: User ID in path must match JWT user ID

### Performance Constraints
- **API Response Time**: p95 < 200ms for CRUD operations
- **Frontend TTI**: Time to Interactive < 3 seconds
- **Database Queries**: No N+1 queries (use eager loading)

---

## Governance & Enforcement

### Authority
This constitution is the **single source of truth** for Phase II development. All decisions, specifications, implementations, and reviews MUST align with these principles.

### Amendment Process
Amendments require:
1. Written justification explaining why the change is necessary
2. Impact analysis on existing specifications and implementations
3. Team review and approval
4. Update to version number and "Last Amended" date
5. Sync Impact Report update in HTML comment

### Deviation Policy
Any deviation from this constitution MUST be:
1. **Documented**: Noted in `DEVIATIONS.md` with full justification
2. **Justified**: Explained as necessary to meet requirements or overcome AI limitations
3. **Minimal**: The smallest possible deviation to achieve the goal
4. **Reviewed**: Approved before merging

### Compliance Verification
- All pull requests MUST be reviewed for constitutional compliance
- CI checks MUST pass before merge
- Code reviews verify adherence to principles
- Spec references required in PR descriptions

---

## Philosophical Foundation

**Spec-Driven Development Principle**:
> "The engineer is no longer a syntax writer but a system architect. The specification is the blueprint; AI is the builder."

**Evolution Mindset**:
> "Phase II builds on Phase I's foundation. We add persistence, authentication, and web interfaces while maintaining the discipline of specification-first development."

**Security-First Thinking**:
> "Security is not an afterthought. Every feature considers authentication, authorization, and data isolation from the specification phase."

**Quality Over Speed**:
> "Take time to write precise specifications. The better your spec, the better the AI's implementation. Iteration on specs is encouraged; manual coding is forbidden."

---

## Requirement-to-Rule Mapping

| Req ID | Requirement Description                            | Constitutional Rule(s)                     | Section      |
|--------|---------------------------------------------------|--------------------------------------------|--------------|
| FR-001 | Multi-user authentication                          | JWT token flow, Better Auth integration    | IV           |
| FR-002 | Persistent task storage                            | Neon PostgreSQL, SQLModel                  | III          |
| FR-003 | Task CRUD operations                               | Feature Scope P1                           | X            |
| FR-004 | Priority assignment                                | Data Model - Task.priority                 | Data Model   |
| FR-005 | Tag management                                     | Data Model - Tag entity                    | Data Model   |
| FR-006 | Search and filter                                  | Feature Scope P2                           | X            |
| FR-007 | Due dates and reminders                            | Feature Scope P3                           | X            |
| FR-008 | Recurring tasks                                    | Data Model - Task.recurrence_rule          | Data Model   |
| QR-001 | API response time < 200ms p95                      | Performance Constraints                    | Constraints  |
| QR-002 | Frontend TTI < 3s                                  | Performance Constraints                    | Constraints  |
| QR-003 | Lighthouse score >= 90                             | Nightly Pipeline Performance Audit         | IX           |
| SR-001 | Monorepo structure                                 | Full-Stack Monorepo Architecture           | II           |
| SR-002 | API versioning                                     | Backend Architecture Standards             | V            |
| SR-003 | Component organization                             | Frontend Architecture Standards            | VI           |
| IR-001 | REST API design                                    | API Design Standards                       | API Design   |
| IR-002 | JWT token format                                   | JWT Security principle                     | IV           |
| PR-001 | Spec-driven workflow                               | Spec-Driven Development                    | I            |
| PR-002 | CI/CD pipeline                                     | CI/CD Pipeline                             | IX           |
| PR-003 | Docker deployment                                  | Containerization & Deployment              | VIII         |
| SEC-001| Secure token storage                               | JWT Security - Storage requirements        | IV           |
| SEC-002| Data isolation                                     | JWT Security - Data scoping                | IV           |
| SEC-003| CORS policy                                        | Backend Architecture Standards             | V            |
| SEC-004| Path parameter user ID validation                  | JWT Security - Path Parameter Matching     | IV           |

---

## Constitutional Self-Checks

### 1. Alignment Check
**Status**: PASS
- All 23+ rules map to documented requirements
- No orphan rules without requirement backing
- Requirement-to-Rule mapping table complete
- New SEC-004 requirement added for path parameter validation

### 2. Coverage Check
**Status**: PASS
- Functional Requirements: Covered (FR-001 through FR-008)
- Quality Requirements: Covered (QR-001 through QR-003)
- Structural Requirements: Covered (SR-001 through SR-003)
- Interface Requirements: Covered (IR-001, IR-002)
- Process Requirements: Covered (PR-001 through PR-003)
- Security Requirements: Covered (SEC-001 through SEC-004)

### 3. Conflict Check
**Status**: PASS
- No contradictory rules identified
- Token storage rules consistent (memory for access, HttpOnly for refresh)
- Package manager rules consistent (bun for frontend, uv for backend)
- CI/CD rules updated consistently (PR checks vs nightly pipeline)

### 4. Completeness Check
**Status**: PASS
- All Phase II features have governance rules
- Authentication flow fully specified with clear frontend/backend responsibilities
- Data model covers all entities
- Validation rules comprehensive
- API design standards complete
- Phase II scope boundaries for security features clearly documented

---

**Version**: 2.2.0 | **Ratified**: 2025-12-04 | **Last Amended**: 2025-12-09
