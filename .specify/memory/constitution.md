<!--
SYNC IMPACT REPORT:
Version Change: 2.4.0 -> 2.5.0
Amendment Date: 2025-12-25

Modified Sections:

  - Mission Statement:
    * CHANGED: Updated Phase III status from ACTIVE to COMPLETE
    * ADDED: Phase IV Kubernetes deployment as NEW, ACTIVE implementation
    * RATIONALE: Phase III completed; Phase IV adds orchestration and production deployment patterns

  - Core Principles:
    * ADDED: Principle XIV - Containerization & Orchestration (Phase IV only)
    * ADDED: Principle XV - Production-Grade Deployment (Phase IV only)
    * RATIONALE: Governs Phase IV Kubernetes architecture, Helm charts, and production features

  - Repository Structure (Principle II):
    * ADDED: /phaseIV/ directory structure with kubernetes/ subdirectory
    * ADDED: Phase IV-specific directory layout (frontend, backend, kubernetes/helm/, scripts)
    * ADDED: Exception clause for container artifact reuse from Phase III
    * RATIONALE: Phase IV deploys Phase III containers; exception clarifies constitutional compliance

  - Specs Organization:
    * ADDED: `/specs/sphaseIV/` directory for Phase IV specifications
    * RATIONALE: Maintains spec organization pattern for new phase

  - Technology Constraints:
    * ADDED: Phase IV-specific technology stack (Docker, Kubernetes, Minikube, Helm, Nginx Ingress)
    * ADDED: Cluster requirements (4 CPU, 8GB RAM minimum)
    * ADDED: Namespace requirement (todo-phaseiv)
    * RATIONALE: Enforces mandatory orchestration stack for Phase IV hackathon

  - Success Criteria:
    * ADDED: Phase IV-specific functional requirements (4 services deployed, Ingress, HPA, Redis persistence)
    * ADDED: Phase IV-specific technical requirements (Helm best practices, health probes, resource limits)
    * ADDED: Phase IV-specific documentation requirements (KUBERNETES_GUIDE.md, RUNBOOK.md)
    * ADDED: Phase IV-specific testing requirements (E2E, load, resilience, persistence, ingress tests)
    * RATIONALE: Defines completion criteria for Phase IV hackathon

  - Requirement-to-Rule Mapping:
    * ADDED: Phase IV functional requirements (FR-P4-001 through FR-P4-010)
    * ADDED: Phase IV structural requirements (SR-P4-001 through SR-P4-004)
    * ADDED: Phase IV technology constraints (TC-P4-001 through TC-P4-004)
    * RATIONALE: Maintains traceability for Phase IV governance

  - Workflow Guidance (Principle I):
    * ADDED: Phase IV-specific Spec-Driven Development workflow (Specification → Generation → Validation → Deployment → Testing)
    * RATIONALE: Kubernetes deployment requires infrastructure-as-code specification approach

Templates Requiring Updates:
  - None - existing templates remain compatible

Follow-up TODOs:
  - Create initial comprehensive spec in /specs/sphaseIV/001-kubernetes-deployment/
  - Generate Helm charts in /phaseIV/kubernetes/helm/todo-app/
  - Create KUBERNETES_GUIDE.md and RUNBOOK.md documentation
-->

# Todo App - Multi-Phase Constitution

## Mission Statement

This project implements a todo application across four distinct phases, each with complete separation:

**Phase I (COMPLETED)**: Command-line interface (CLI) todo application with in-memory storage and rich terminal UI.

**Phase II (COMPLETED)**: Full-stack web application with persistent storage, multi-user authentication via Better Auth, Next.js frontend, and FastAPI backend.

**Phase III (COMPLETED)**: AI-powered chatbot interface for managing todos through natural language using MCP (Model Context Protocol) server architecture and OpenAI Agents SDK.

**Phase IV (ACTIVE)**: Kubernetes deployment with Helm charts, enabling local orchestration via Minikube with production-grade features (Nginx Ingress, Horizontal Pod Autoscaling, Persistent Volumes).

Each phase is a **completely independent implementation** with no code sharing between phases. The constitution governs all phases while providing phase-specific guidance.

---

## Core Principles

### I. Spec-Driven Development (Mandatory)

**Philosophy**: The specification is the single source of truth; AI is the implementation engine.

**Requirements**:
- ALL frontend and backend code MUST be generated by an AI agent from written specifications in the `/specs` directory.
- Manual coding of features, business logic, UI components, or API endpoints is **strictly forbidden**, with one documented exception.
- **Exception for AI Limitations**: In the rare event that the AI code generator cannot produce a correct implementation for a well-defined specification after reasonable refinement efforts (iterating on prompts, breaking down complexity, adjusting specification clarity), a developer may manually write the minimum necessary code. This action MUST be:
  1. Documented in `DEVIATIONS.md` with full justification including refinement attempts made
  2. Reviewed by the team before merging
  3. Tagged with `[AI-LIMITATION]` in commit message
  4. Accompanied by the specification that was attempted
- Development follows the cycle: **Spec --> AI Generate --> Test --> Refine Spec --> Regenerate**.
- Specifications MUST be managed via GitHub Spec-Kit Plus in the `/specs` directory.
- Spec organization MUST follow the default Specify Plus Kit structure:
  - Phase I: `/specs/sphaseI/NNN-feature-name/`
  - Phase II: `/specs/sphaseII/NNN-feature-name/`
  - Phase III: `/specs/sphaseIII/NNN-feature-name/`
  - Phase IV: `/specs/sphaseIV/NNN-feature-name/`
  - Each feature directory contains `spec.md`, `plan.md`, `tasks.md`, and related artifacts.
- **Phase IV Workflow**: Phase IV follows infrastructure-as-code specification approach:
  1. **Specification Phase**: Create comprehensive spec.md covering infrastructure, Helm charts, deployments, production features, and testing
  2. **Generation Phase**: AI generates Helm charts, Kubernetes manifests, scripts, and documentation from spec
  3. **Validation Phase**: Run `helm lint`, `helm template`, and dry-run deployments to validate generated artifacts
  4. **Deployment Phase**: Incremental rollout (Redis → MCP → Backend → Frontend → Ingress)
  5. **Testing Phase**: Execute helm tests, E2E tests, load tests, resilience tests, persistence tests, ingress tests

**Verification**:
- Commit history shows specification files created/modified before implementation files.
- Pull request descriptions reference the spec file(s) that drive the implementation.
- No implementation PRs without corresponding spec file changes or references.

**Rationale**: AI-driven development ensures consistency, reduces human error, maintains clear traceability from specification to implementation, and demonstrates the viability of AI-first software engineering at scale.

---

### II. Repository Structure

**Philosophy**: Complete phase separation with unified governance.

**Requirements**:
- **Repository Structure**: Monorepo with distinct directories per phase:
  - `/phaseI` - CLI application (Python, Rich UI) - COMPLETED
  - `/phaseII` - Full-stack web application (Next.js + FastAPI) - COMPLETED
  - `/phaseIII` - AI Chatbot (OpenAI ChatKit + FastAPI + MCP) - COMPLETED
  - `/phaseIV` - Kubernetes Deployment (Minikube + Helm + Nginx Ingress) - ACTIVE
  - `/specs` - All specifications organized by phase
  - `/.specify` - Spec-Kit Plus configuration and templates

**Phase Separation Requirements**:
- **NO IMPORTS** between phases (e.g., phaseIII MUST NOT import from phaseII)
- **NO SHARED CODE** or modules between phases
- **INDEPENDENT IMPLEMENTATIONS** - each phase reimplements required functionality
- **SEPARATE DATABASE TABLES** - Phase III uses `tasks_phaseiii` table, not Phase II tables

**Phase IV Exception for Container Artifact Reuse**:
Phase IV deploys containerized versions of Phase III services. While source code separation is maintained (Phase IV does not import Phase III source files directly), Phase IV Dockerfiles build from Phase III source directories located in `/phaseIV/frontend/` and `/phaseIV/backend/`.

This is constitutionally acceptable because:
- Docker images are deployment artifacts, not source code
- Helm charts and Kubernetes manifests are Phase IV-specific implementations
- Phase IV demonstrates deployment/orchestration patterns, not new application logic
- Source code remains separated (no cross-phase imports at runtime)

**Phase III Directory Structure**:
```
phaseIII/
├── backend/                    # Python FastAPI backend
│   ├── pyproject.toml         # UV package manager
│   ├── .env.example
│   ├── alembic/               # Database migrations (independent)
│   │   ├── env.py
│   │   └── versions/
│   ├── app/
│   │   ├── main.py            # FastAPI app entry point
│   │   ├── config.py          # Configuration
│   │   ├── database.py        # Database connection
│   │   ├── models/            # SQLModel models
│   │   │   ├── __init__.py
│   │   │   ├── task.py        # Task model (independent from Phase II)
│   │   │   ├── conversation.py # Conversation model
│   │   │   └── message.py     # Message model
│   │   ├── services/          # Business logic
│   │   │   ├── __init__.py
│   │   │   ├── task_service.py  # Task CRUD (independent implementation)
│   │   │   └── chat_service.py  # Chat service with OpenAI
│   │   ├── mcp/               # MCP Server
│   │   │   ├── __init__.py
│   │   │   ├── server.py      # MCP server manager
│   │   │   └── tools.py       # MCP tool implementations
│   │   ├── routers/           # API routes
│   │   │   ├── __init__.py
│   │   │   └── chat.py        # Chat endpoint
│   │   └── schemas/           # Pydantic schemas
│   │       ├── __init__.py
│   │       ├── task.py
│   │       └── chat.py
│   └── tests/                 # Pytest tests
│       ├── conftest.py
│       ├── test_mcp_tools.py
│       └── test_chat.py
├── frontend/                   # OpenAI ChatKit UI
│   ├── package.json           # Bun package manager
│   ├── bun.lockb
│   ├── .env.example
│   ├── next.config.js
│   ├── app/
│   │   └── chat/
│   │       └── page.tsx
│   ├── components/
│   │   └── chat/
│   │       ├── ChatInterface.tsx
│   │       └── ChatMessage.tsx
│   └── lib/
│       ├── api/
│       │   └── chat.ts
│       └── auth.ts            # Better Auth integration
└── README.md
```

**Phase II Directory Structure** (Reference - COMPLETED):
```
phaseII/
├── frontend/
│   ├── src/
│   │   ├── app/           # Next.js App Router pages
│   │   ├── components/    # Reusable UI components
│   │   ├── lib/           # Utilities, API client, stores
│   │   └── types/         # TypeScript type definitions
│   ├── public/
│   └── package.json
├── backend/
│   ├── src/
│   │   ├── routers/       # APIRouter modules
│   │   ├── models/        # SQLModel entities
│   │   ├── schemas/       # Pydantic schemas
│   │   ├── services/      # Business logic
│   │   └── core/          # Config, dependencies, security
│   ├── tests/
│   ├── alembic/
│   └── pyproject.toml
└── docker-compose.yml
```

**Phase IV Directory Structure** (ACTIVE):
```
phaseIV/
├── frontend/                    # Next.js frontend (from Phase III)
├── backend/                     # FastAPI backend (from Phase III)
├── kubernetes/                  # NEW: Kubernetes-specific artifacts
│   ├── helm/
│   │   └── todo-app/            # Helm chart (20 YAML templates)
│   │       ├── Chart.yaml
│   │       ├── values.yaml
│   │       ├── templates/
│   │       │   ├── frontend-deployment.yaml
│   │       │   ├── backend-deployment.yaml
│   │       │   ├── mcp-deployment.yaml
│   │       │   ├── redis-statefulset.yaml
│   │       │   ├── ingress.yaml
│   │       │   ├── hpa-frontend.yaml
│   │       │   ├── hpa-backend.yaml
│   │       │   └── ...
│   │       └── tests/
│   ├── scripts/                 # Deployment automation
│   │   ├── setup-minikube.sh
│   │   ├── deploy.sh
│   │   └── test.sh
│   └── docs/
│       ├── KUBERNETES_GUIDE.md
│       └── RUNBOOK.md
├── docker-compose.yml           # Local Docker Compose (from Phase III)
└── DOCKER_GUIDE.md              # Docker documentation
```

**Specs Directory Structure**:
```
specs/
├── sphaseI/               # Phase I specifications (COMPLETED)
│   ├── 001-add-task/
│   ├── 002-view-task/
│   └── ...
├── sphaseII/              # Phase II specifications (COMPLETED)
│   ├── 001-foundational-backend-setup/
│   ├── 002-task-tag-api/
│   └── ...
├── sphaseIII/             # Phase III specifications (COMPLETED)
│   ├── 001-mcp-server-setup/
│   ├── 002-chat-endpoint/
│   └── ...
└── sphaseIV/              # Phase IV specifications (ACTIVE)
    └── 001-kubernetes-deployment/
        ├── spec.md
        ├── plan.md
        └── tasks.md
```

**Rationale**: Complete phase separation ensures each implementation is independent and can evolve without affecting other phases. This also demonstrates the ability to implement the same functionality using different architectural approaches.

---

### III. Persistent & Relational State

**Philosophy**: Production-grade persistence with cloud-native infrastructure.

**Requirements**:
- **Database**: Neon Serverless PostgreSQL as the single source of truth.
- **ORM**: SQLModel MUST be used for all data access (combines SQLAlchemy and Pydantic).
- **Async Access**: All database operations MUST use asyncpg driver for non-blocking I/O.
- **Migrations**: Schema changes MUST be managed via Alembic migrations:
  - Every schema change requires a migration file
  - Migrations MUST be reversible (include upgrade AND downgrade)
  - Migration naming: `YYYYMMDD_HHMMSS_descriptive_name.py`
- **Connection Pooling**: Production deployments MUST use connection pooling.
- **Data Isolation**: ALL database queries MUST scope to the authenticated user's ID from the JWT token, NOT from the path parameter. The JWT user_id is the authoritative source for determining data access rights.
- **Multi-User Isolation Testing**: All data access functions MUST include tests that verify User A cannot access User B's data, even with valid authentication.
- **Phase Table Separation**: Phase III MUST use separate tables (e.g., `tasks_phaseiii`) to avoid conflicts with Phase II data.

**Verification**:
- No raw SQL queries outside of migrations
- All queries include user_id filter from JWT token (enforced via FastAPI dependencies)
- Alembic migration history matches production schema
- Database connection uses async context managers
- Multi-user isolation tests pass for all endpoints
- Path parameter user_id validation is enforced at API level

**Rationale**: Neon provides serverless PostgreSQL with automatic scaling, SQLModel provides type-safe data access, and Alembic ensures reproducible schema evolution across environments. The JWT user_id as the authoritative source ensures that even if path parameters are manipulated, data access remains secure.

---

### IV. User Authentication & JWT Security (The JWT Challenge)

**Philosophy**: Secure, stateless authentication with defense-in-depth token management.

**Requirements**:

**Authentication Flow**:
1. **Frontend Auth**: Better Auth library handles user signup/login UI on Next.js frontend with JWT plugin enabled. Frontend uses Better Auth client-side session management for user authentication state.
2. **Token Issuance**: Better Auth handles JWT token generation and management on the frontend. The Better Auth JWT plugin issues access tokens that are validated by the backend using a shared secret.
3. **Token Management**: Better Auth automatically manages token refresh and storage. Frontend MUST use Better Auth's built-in session management rather than implementing custom token storage.
4. **Token Attachment**: Frontend axios interceptor retrieves the Better Auth JWT token from the session and attaches it to `Authorization: Bearer <token>` header on all protected requests.
5. **Token Refresh Flow**: Better Auth handles automatic token refresh when needed. The backend only validates tokens according to the shared secret.
6. **Backend Validation**: FastAPI dependency validates Better Auth JWT tokens on all protected endpoints using the shared secret:
   - Verify signature with Better Auth shared secret key
   - Check expiration
   - Extract user_id from payload
   - **Path Parameter Matching**: When user ID appears in the API path (e.g., `/api/{user_id}/tasks`), the backend MUST compare the `user_id` extracted from the validated JWT against the `user_id` path parameter. If they do not match, return 403 Forbidden. This prevents users from accessing other users' resources even with a valid token.
   - **Data Scoping**: User ID from JWT payload MUST scope ALL database queries. All queries MUST be based on the JWT user_id, NOT the path parameter, to ensure data integrity.
7. **Secure Storage**: Better Auth manages token storage using browser storage mechanisms. The JWT plugin ensures secure handling of tokens.

**JWT Token Structure** (issued by Better Auth):
```json
{
  "sub": "<user_id>",
  "email": "<user_email>",
  "exp": "<expiration_timestamp>",
  "iat": "<issued_at_timestamp>",
  "role": "<user_role>"
}
```

**Security Standards**:
- MUST use HS256 algorithm with Better Auth shared secret
- Secret keys MUST be at least 256 bits
- Rate limiting on auth endpoints: 5 attempts per minute per IP
- All API endpoints that accept user_id in path MUST validate that the JWT user_id matches the path user_id

**Future Scope**:
The following security features are explicitly OUT OF SCOPE for current phases and targeted for future implementation:
- **Refresh token rotation**: Rotating refresh tokens on each use
- **Token blacklisting**: Server-side token revocation for logout

**Rationale**: These features add complexity that exceeds current scope. The current implementation provides adequate security for the MVP while clearly identifying enhancement paths.

**Verification**:
- All protected routes return 401 without valid token
- Expired tokens return 401 and trigger refresh flow through Better Auth
- User A cannot access User B's data (data isolation test)
- Path parameter user ID mismatches return 403 Forbidden
- All database queries are scoped to JWT user_id, not path parameter

**Rationale**: Using Better Auth's JWT plugin simplifies frontend authentication while maintaining security through shared secret validation on the backend. The path parameter validation ensures that users can only access resources that belong to them.

---

### V. Backend Architecture Standards

**Philosophy**: Clean, testable, and maintainable API design.

**Requirements**:

**Router Organization**:
- Endpoints organized in `/backend/src/routers/` (Phase II) or `/backend/app/routers/` (Phase III) using FastAPI APIRouter
- One router file per resource domain (e.g., `tasks.py`, `auth.py`, `chat.py`)
- Routers registered in `main.py` with version prefix

**API Versioning**:
- ALL routes prefixed with `/api/v1/` or `/api/{user_id}/`
- Version changes require new router files (e.g., `/api/v2/tasks`)
- Breaking changes MUST increment API version

**Configuration**:
- pydantic-settings for environment-based configuration
- `.env` files for local development (NEVER committed)
- Environment variables for production secrets
- `Settings` class validates all config on startup

**Documentation**:
- FastAPI automatic OpenAPI documentation MUST be enabled
- Swagger UI available at `/docs`
- ReDoc available at `/redoc`
- All endpoints MUST have docstrings describing behavior

**Security**:
- CORS policy MUST restrict to deployed frontend domain only
- Local development may allow localhost origins
- All inputs validated via Pydantic models
- SQL injection prevented via SQLModel parameterization
- Rate limiting on sensitive endpoints

**Error Handling**:
- Consistent error response format:
  ```json
  {
    "detail": "Human-readable message",
    "code": "ERROR_CODE",
    "field": "optional_field_name"
  }
  ```
- Standard HTTP status codes (400, 401, 403, 404, 422, 500)
- No stack traces in production responses

**Logging**:
- Structured JSON logging in production
- Request ID tracking across services
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL

**Pre-commit Hooks**:
- `ruff check` - linting MUST pass
- `ruff format` - formatting MUST pass
- `pip-audit` - security vulnerability check

**Rationale**: Consistent API design enables frontend predictability, proper error handling improves debugging, and pre-commit hooks catch issues before they enter the codebase.

---

### VI. Frontend Architecture Standards

**Philosophy**: Fast, accessible, and delightful user experience.

**Phase II Frontend Requirements**:

**Component Structure**:
- Feature-based or type-based organization (choose one, be consistent)
- Feature-based example: `/components/tasks/TaskCard.tsx`
- Type-based example: `/components/ui/Button.tsx`
- shadcn/ui components in `/components/ui/`

**State Management**:
- Zustand for global state (auth state, user preferences)
- React Query or SWR for server state (tasks, tags)
- Local component state for UI-only state

**Authentication Integration**:
- Better Auth library MUST be used for all authentication functionality
- User sessions managed through Better Auth client-side session management
- API client at `@/lib/api-client` MUST be implemented to handle Better Auth token attachment
- Axios interceptor MUST retrieve Better Auth JWT token and attach to `Authorization: Bearer <token>` header
- User ID MUST be extracted from Better Auth session for URL construction with new API pattern

**API Client Implementation**:
- Create API client at `@/lib/api-client` that integrates with Better Auth
- Client MUST construct URLs using the pattern `/api/{user_id}/{resources}` using the user ID from session
- Client MUST handle 403 Forbidden responses by redirecting to appropriate error states
- Client MUST handle 401 Unauthorized responses by allowing Better Auth to manage token refresh

**Phase III Frontend Requirements**:

**OpenAI ChatKit Integration**:
- MUST use OpenAI ChatKit for the chat interface
- Domain allowlist MUST be configured in OpenAI platform settings
- ChatKit domain key MUST be obtained and configured

**Chat Interface Requirements**:
- Message display with user/assistant role differentiation
- Loading states during AI processing
- Tool call visualization (show which MCP tools were invoked)
- Conversation history display
- Error handling with graceful recovery

**Common Requirements (All Phases)**:

**Environment Variables**:
- `NEXT_PUBLIC_` prefix for browser-exposed variables
- Server-only variables for API keys and secrets
- Type-safe env access via zod validation

**User Experience Standards**:
- **Optimistic UI Updates**: UI updates immediately, reverts on server error
- **Skeleton Loading States**: Show content placeholders during data fetch
- **Toast Notifications**: Non-blocking feedback for actions (success, error)
- **Input Debouncing**: 300ms debounce on search inputs
- **Error Boundaries**: Graceful error handling with recovery options
- **Responsive Design**: Mobile-first, works on all screen sizes

**Accessibility Standards**:
- ARIA labels on interactive elements
- Keyboard navigation support
- Color contrast meets WCAG AA
- Focus management for modals and dialogs

**Performance Standards**:
- First Contentful Paint < 1.5s
- Time to Interactive < 3s
- Bundle size monitoring in CI

**Rationale**: Consistent UX patterns reduce user frustration, optimistic updates feel instant, and accessibility ensures the app works for everyone.

---

### VII. Automated Testing Standards

**Philosophy**: Comprehensive testing enables confident refactoring and continuous deployment.

**Backend Testing Requirements**:
- **Framework**: pytest with pytest-asyncio for async tests
- **Database Isolation**: testcontainers for isolated PostgreSQL per test suite
- **Test Categories**:
  - Unit tests: Business logic in `/services/`
  - Integration tests: API endpoints with database
  - Contract tests: API schema validation
- **Coverage**: Minimum 80% code coverage on core logic
- **Execution**: `cd backend && uv run pytest`

**Frontend Testing Requirements**:
- **Framework**: Vitest (or Jest) with React Testing Library
- **Test Categories**:
  - Unit tests: Utility functions, hooks
  - Component tests: Isolated component behavior
  - Integration tests: User flows with MSW mocking
- **Coverage**: Minimum 70% code coverage on components
- **Execution**: `cd frontend && bun test`

**Phase III Specific Testing**:
- **MCP Tool Tests**: All 5 MCP tools MUST have unit tests
- **Chat Service Tests**: Conversation flow, tool invocation, error handling
- **Integration Tests**: End-to-end chat interactions with mocked OpenAI responses

**End-to-End Testing (Optional)**:
- Playwright for critical user journeys
- Run in CI on staging deployments

**Test Naming Convention**:
- `test_<action>_<condition>_<expected_result>`
- Example: `test_create_task_with_empty_title_returns_400`

**Verification**:
- All tests pass before merge (enforced in CI)
- Coverage reports generated and tracked
- No skipped tests without justification comment

**Rationale**: Comprehensive testing catches regressions, enables refactoring, and provides documentation of expected behavior.

---

### VIII. Containerization & Deployment

**Philosophy**: Environment parity from development to production.

**Requirements**:

**Docker Configuration**:
- `Dockerfile` in each phase's `/frontend` for production build
- `Dockerfile` in each phase's `/backend` for production build
- `docker-compose.yml` at phase root for local development environment
- Multi-stage builds to minimize image size

**Local Development**:
- `docker-compose up` starts all services (frontend, backend, database)
- Hot-reload enabled for both frontend and backend
- Local PostgreSQL or Neon dev branch for database

**Environment Management**:
- Development: Local Docker Compose or direct processes
- Staging: Auto-deploy from main branch
- Production: Deploy from tagged releases

**Health Checks**:
- Backend: `/health` endpoint returns service status
- Frontend: Next.js built-in health checks
- Database: Connection verification on startup

**Rationale**: Docker ensures consistent environments, reduces "works on my machine" issues, and simplifies deployment pipeline.

---

### IX. CI/CD Pipeline

**Philosophy**: Automated quality gates and deployment with practical iteration speed.

**Requirements**:

**GitHub Actions Workflows**:

**PR Checks** (on pull_request) - Fast feedback for developers:
- Lint frontend: `bun run lint`
- Lint backend: `ruff check .`
- Test frontend: `bun test`
- Test backend: `uv run pytest`
- Build frontend: `bun run build`
- Type check frontend: `bun run typecheck`
- **Coverage Gate**: PR MUST NOT decrease overall test coverage percentage (compare against main branch baseline)

**Nightly Pipeline** (scheduled, runs on main branch) - Comprehensive health checks:
- All PR checks
- **Coverage Threshold Check**: Backend coverage >= 80%, Frontend coverage >= 70%
- **Performance Audit**: Lighthouse Performance score >= 90
- **Security Scan**: Dependency vulnerability audit
- **Report Generation**: Publish results to team dashboard/notifications
- **Non-blocking**: Failures generate alerts but do not block development

**Rationale for Pipeline Separation**: Expensive performance audits and strict threshold checks on every PR slow development velocity. Moving these to a nightly pipeline maintains quality standards while enabling faster iteration. PRs focus on not regressing quality; nightly checks ensure absolute thresholds are met.

**Staging Deploy** (on push to main):
- All PR checks pass
- Auto-deploy to staging environment
- Run smoke tests against staging

**Production Deploy** (on release tag):
- All checks pass
- Manual approval (optional)
- Deploy to production environment
- Tag docker images with version

**Branch Protection**:
- main branch requires PR
- PRs require passing CI checks
- PRs require at least 1 approval (if team > 1)

**Secrets Management**:
- GitHub Secrets for deployment credentials
- Rotate secrets quarterly
- Never commit secrets to repository

**Rationale**: CI/CD automation ensures consistent quality, prevents broken deployments, and enables rapid iteration while nightly checks maintain long-term code health.

---

### X. Feature Scope (Phase II - COMPLETED)

**Philosophy**: Expand core functionality with user-centric features.

**Basic Features (Priority P1 - MVP)**:
1. **Add Task** - Create task with title, description, priority
2. **View Tasks** - Display paginated task list with status indicators
3. **Update Task** - Modify task title, description, priority, due date
4. **Delete Task** - Remove task with confirmation
5. **Mark Complete** - Toggle task completion status

**Intermediate Features (Priority P2)**:
6. **Priorities** - High, Medium, Low priority assignment
7. **Tags/Categories** - Create, assign, and manage task tags
8. **Search** - Full-text search across task titles and descriptions
9. **Filter** - Filter by status (all, pending, completed), priority, tag
10. **Sort** - Sort by due date, priority, creation date, title

**Advanced Features (Priority P3)**:
11. **Due Dates** - Set due dates with visual indicators
12. **Time Reminders** - Browser push notifications for due tasks
13. **Recurring Tasks** - iCal RRULE format for recurring schedules

**Explicitly Out of Scope for Phase II**:
- Team/organization features
- Task sharing or collaboration
- File attachments
- Subtasks or task dependencies
- Integrations with external services (calendar, email)
- Mobile native applications

**Rationale**: Prioritized feature scope ensures MVP delivery while planning for valuable enhancements without scope creep.

---

### XI. MCP Server Architecture (Phase III)

**Philosophy**: Standardized interface for AI to interact with the application through stateless, database-backed tools.

**Requirements**:

**MCP Server Setup**:
- MUST use the official MCP SDK: https://github.com/modelcontextprotocol/python-sdk
- Server MUST expose exactly 5 tools for task operations
- All tools MUST be stateless - no in-memory state between requests
- All state MUST be persisted to the database

**Tool Specifications**:

| Tool | Purpose | Required Parameters | Optional Parameters |
|------|---------|---------------------|---------------------|
| `add_task` | Create a new task | `user_id`, `title` | `description` |
| `list_tasks` | Retrieve user's tasks | `user_id` | `status` (all/pending/completed) |
| `complete_task` | Mark task as complete | `user_id`, `task_id` | - |
| `delete_task` | Remove a task | `user_id`, `task_id` | - |
| `update_task` | Modify task | `user_id`, `task_id` | `title`, `description` |

**Tool Response Format**:
```json
{
  "task_id": <integer>,
  "status": "<created|completed|deleted|updated>",
  "title": "<task_title>"
}
```

**Error Handling**:
- Tool errors MUST return descriptive error messages
- Invalid task_id MUST return "Task not found" error
- All errors MUST be gracefully handled without crashing the server

**Rationale**: MCP provides a standardized interface for AI agents to interact with the application, enabling tool composition and clear separation between AI logic and application logic.

---

### XII. OpenAI Agents SDK Integration (Phase III)

**Philosophy**: Leverage OpenAI's agent framework for natural language task management.

**Requirements**:

**SDK Integration**:
- MUST use OpenAI Agents SDK: https://github.com/openai/openai-agents-python
- Agent MUST be configured with MCP tools for task operations
- Agent MUST understand natural language intent and invoke appropriate tools

**Agent Behavior Specification**:

| User Intent | Agent Action |
|-------------|--------------|
| Adding/creating/remembering something | Invoke `add_task` |
| Viewing/showing/listing tasks | Invoke `list_tasks` with appropriate filter |
| Done/complete/finished with task | Invoke `complete_task` |
| Delete/remove/cancel task | Invoke `delete_task` |
| Change/update/rename task | Invoke `update_task` |

**Conversation Context**:
- Agent MUST receive last 20 messages for context
- Conversation history MUST be loaded from database
- New messages MUST be stored before agent invocation

**Response Requirements**:
- Agent MUST confirm actions with friendly responses
- Agent MUST explain what tools were invoked
- Agent MUST handle errors gracefully with helpful messages

**Rationale**: OpenAI Agents SDK provides robust AI capabilities for natural language understanding and tool invocation, enabling intuitive conversational task management.

---

### XIII. Conversational AI Standards (Phase III)

**Philosophy**: Stateless server architecture with database-persisted conversation state.

**Requirements**:

**Stateless Architecture**:
- Server MUST NOT hold conversation state in memory
- Each request MUST be independent and self-contained
- Server MUST be horizontally scalable
- Server restart MUST NOT lose conversation data

**Conversation Flow (Request Cycle)**:
1. Receive user message via API
2. Fetch conversation history from database (if conversation_id provided)
3. Build message array for agent (history + new message)
4. Store user message in database
5. Run agent with MCP tools
6. Agent invokes appropriate MCP tool(s)
7. Store assistant response in database
8. Return response to client
9. Server holds NO state (ready for next request)

**Conversation Persistence**:
- Conversations MUST be stored in `conversations` table
- Messages MUST be stored in `messages` table with conversation_id reference
- Messages MUST include role (user/assistant) and content
- Messages MUST be ordered by created_at timestamp

**Natural Language Commands**:
The chatbot MUST understand and respond to:
| User Says | Agent Should |
|-----------|--------------|
| "Add a task to buy groceries" | Call `add_task` with title "Buy groceries" |
| "Show me all my tasks" | Call `list_tasks` with status "all" |
| "What's pending?" | Call `list_tasks` with status "pending" |
| "Mark task 3 as complete" | Call `complete_task` with task_id 3 |
| "Delete the meeting task" | Call `list_tasks` first, then `delete_task` |
| "Change task 1 to 'Call mom tonight'" | Call `update_task` with new title |
| "I need to remember to pay bills" | Call `add_task` with title "Pay bills" |
| "What have I completed?" | Call `list_tasks` with status "completed" |

**Rationale**: Stateless architecture enables scalability and resilience while database persistence ensures conversation continuity across requests and server restarts.

---

### XIV. Containerization & Orchestration (Phase IV Only)

**Philosophy**: Infrastructure as Code with declarative Kubernetes configuration.

**Requirements**:

**Container Runtime**:
- Docker Desktop as the container runtime
- Multi-stage Dockerfiles for optimized image sizes
- Docker images as deployment artifacts (not source code)
- Container health checks (liveness and readiness probes)

**Kubernetes Orchestration**:
- Minikube for local Kubernetes cluster (4 CPU, 8GB RAM minimum)
- Namespace isolation (todo-phaseiv)
- Service communication via ClusterIP and internal DNS
- Declarative YAML manifests for all resources

**Helm Package Management**:
- Helm v3.13+ for templating and package management
- Chart follows Helm best practices
- Values externalized in values.yaml
- Templating for environment-specific configuration
- helm lint passes with zero warnings
- helm test validates deployment

**Infrastructure as Code Principles**:
- All infrastructure defined in version control
- Reproducible deployments across environments
- No manual kubectl apply of raw YAML
- Git-tracked Helm charts and values

**Service Architecture**:
```
Minikube Cluster (todo-phaseiv namespace)
├── Frontend Deployment (2-5 replicas, HPA)
├── Backend Deployment (2-5 replicas, HPA)
├── MCP Server Deployment (1 replica)
├── Redis StatefulSet (1 replica, 1Gi PVC)
├── Nginx Ingress (todo-app.local)
│   ├── / → frontend:3000
│   └── /api → backend:8000
└── External: Neon PostgreSQL (shared)
```

**Rationale**: Kubernetes provides production-grade orchestration, Helm enables reusable deployment templates, and Infrastructure as Code ensures reproducibility.

---

### XV. Production-Grade Deployment (Phase IV Only)

**Philosophy**: Production-ready features even in local development environments.

**Requirements**:

**Nginx Ingress Controller (MANDATORY)**:
- MUST use Nginx Ingress Controller for HTTP routing
- Single entry point at todo-app.local
- Path-based routing (/ → frontend, /api → backend)
- Ingress annotations for CORS, rate limiting (optional)
- TLS termination support (optional for local)

**Horizontal Pod Autoscaling (MANDATORY)**:
- Frontend HPA: min 2, max 5 replicas
- Backend HPA: min 2, max 5 replicas
- CPU target: 70%
- Memory target: 80%
- Metrics Server MUST be enabled in Minikube
- HPA status MUST show scaling activity

**Persistent Volumes (MANDATORY)**:
- Redis StatefulSet with 1Gi PersistentVolumeClaim
- Standard StorageClass (Minikube default)
- Data persists across pod restarts
- PVC bound status verified

**Health Probes (MANDATORY)**:
- Liveness probes for all services (frontend, backend, mcp, redis)
- Readiness probes for all services
- Probes configured with appropriate timeouts and thresholds
- Failed probes trigger pod restarts

**Resource Limits and Requests (MANDATORY)**:
- CPU requests and limits defined for all containers
- Memory requests and limits defined for all containers
- Resource quotas prevent cluster overcommitment
- QoS classes: Guaranteed or Burstable (not BestEffort)

**Observability (RECOMMENDED)**:
- Metrics Server for HPA and resource monitoring
- kubectl top pods/nodes commands functional
- Pod logs accessible via kubectl logs
- Optional: Prometheus/Grafana integration

**Testing Requirements**:
- helm test passes
- End-to-end test covers complete user flow
- Load test validates HPA scaling
- Resilience test validates pod restart recovery
- Persistence test validates Redis data retention
- Ingress test validates HTTP routing

**Rationale**: Production-grade features in local development prepare deployments for real-world conditions and demonstrate Kubernetes capabilities.

---

## Data Model Specification

### Phase II Data Models

#### User Entity (SQLModel)

| Field      | Type   | Constraints                          | Description                         |
|------------|--------|--------------------------------------|-------------------------------------|
| id         | str    | PRIMARY KEY                          | User ID from Better Auth            |
| email      | str    | UNIQUE, NOT NULL                     | User's email address                |
| name       | str    | NULLABLE                             | User's display name                 |
| created_at | datetime | NOT NULL, DEFAULT now()            | Account creation timestamp          |

#### Tag Entity (SQLModel)

| Field    | Type   | Constraints                          | Description                         |
|----------|--------|--------------------------------------|-------------------------------------|
| id       | int    | PRIMARY KEY, AUTOINCREMENT           | Unique tag identifier               |
| name     | str    | NOT NULL, max 50 chars               | Tag display name                    |
| color    | str    | NULLABLE, hex format                 | Tag color for UI display            |
| user_id  | str    | FOREIGN KEY -> User.id, NOT NULL     | Owner of the tag                    |

**Constraint**: UNIQUE(name, user_id) - No duplicate tag names per user

#### Task Entity (SQLModel) - Phase II

| Field           | Type         | Constraints                          | Description                         |
|-----------------|--------------|--------------------------------------|-------------------------------------|
| id              | int          | PRIMARY KEY, AUTOINCREMENT           | Unique task identifier              |
| title           | str          | NOT NULL, 1-200 chars                | Task title                          |
| description     | str          | NULLABLE, max 1000 chars             | Detailed description                |
| completed       | bool         | NOT NULL, DEFAULT False              | Completion status                   |
| priority        | str          | NOT NULL, DEFAULT 'medium'           | Enum: 'low', 'medium', 'high'       |
| due_date        | datetime     | NULLABLE                             | Task due date and time              |
| recurrence_rule | str          | NULLABLE                             | iCal RRULE string                   |
| user_id         | str          | FOREIGN KEY -> User.id, NOT NULL     | Task owner                          |
| created_at      | datetime     | NOT NULL, DEFAULT now()              | Creation timestamp                  |
| updated_at      | datetime     | NOT NULL, DEFAULT now(), ON UPDATE   | Last modification timestamp         |
| tags            | List[Tag]    | Many-to-Many via TaskTagLink         | Associated tags                     |

#### TaskTagLink Entity (Junction Table)

| Field   | Type | Constraints                          | Description                         |
|---------|------|--------------------------------------|-------------------------------------|
| task_id | int  | FOREIGN KEY -> Task.id, PRIMARY KEY  | Task reference                      |
| tag_id  | int  | FOREIGN KEY -> Tag.id, PRIMARY KEY   | Tag reference                       |

**Constraint**: Composite PRIMARY KEY(task_id, tag_id)

### Phase III Data Models

**IMPORTANT**: Phase III uses SEPARATE tables from Phase II to maintain complete separation.

#### Task Entity (SQLModel) - Phase III

**Table Name**: `tasks_phaseiii` (NOT the Phase II `tasks` table)

| Field       | Type     | Constraints                          | Description                         |
|-------------|----------|--------------------------------------|-------------------------------------|
| id          | int      | PRIMARY KEY, AUTOINCREMENT           | Unique task identifier              |
| user_id     | str      | INDEX, NOT NULL                      | Owner user ID from Better Auth      |
| title       | str      | NOT NULL, max 200 chars              | Task title                          |
| description | str      | NULLABLE                             | Task description                    |
| completed   | bool     | NOT NULL, DEFAULT False              | Completion status                   |
| created_at  | datetime | NOT NULL, DEFAULT now()              | Creation timestamp                  |
| updated_at  | datetime | NOT NULL, DEFAULT now(), ON UPDATE   | Last modification timestamp         |

#### Conversation Entity (SQLModel)

**Table Name**: `conversations`

| Field      | Type     | Constraints                          | Description                         |
|------------|----------|--------------------------------------|-------------------------------------|
| id         | int      | PRIMARY KEY, AUTOINCREMENT           | Unique conversation identifier      |
| user_id    | str      | INDEX, NOT NULL                      | Owner user ID from Better Auth      |
| created_at | datetime | NOT NULL, DEFAULT now()              | Conversation start timestamp        |
| updated_at | datetime | NOT NULL, DEFAULT now(), ON UPDATE   | Last activity timestamp             |

#### Message Entity (SQLModel)

**Table Name**: `messages`

| Field           | Type     | Constraints                          | Description                         |
|-----------------|----------|--------------------------------------|-------------------------------------|
| id              | int      | PRIMARY KEY, AUTOINCREMENT           | Unique message identifier           |
| conversation_id | int      | FOREIGN KEY -> Conversation.id, INDEX| Parent conversation                 |
| user_id         | str      | INDEX, NOT NULL                      | Owner user ID                       |
| role            | str      | NOT NULL                             | 'user' or 'assistant'               |
| content         | text     | NOT NULL                             | Message content                     |
| created_at      | datetime | NOT NULL, DEFAULT now()              | Message timestamp                   |

### Database Indexes

**Phase II Indexes**:
- `idx_tasks_user_id` on tasks(user_id) - User task lookup
- `idx_tasks_user_completed` on tasks(user_id, completed) - Filtered task lists
- `idx_tasks_user_priority` on tasks(user_id, priority) - Priority sorting
- `idx_tasks_user_due_date` on tasks(user_id, due_date) - Due date sorting
- `idx_tags_user_id` on tags(user_id) - User tag lookup
- `idx_task_tag_link_task` on task_tag_link(task_id) - Tag lookup by task
- `idx_task_tag_link_tag` on task_tag_link(tag_id) - Task lookup by tag

**Phase III Indexes**:
- `idx_tasks_phaseiii_user_id` on tasks_phaseiii(user_id) - User task lookup
- `idx_conversations_user_id` on conversations(user_id) - User conversation lookup
- `idx_messages_conversation_id` on messages(conversation_id) - Message lookup by conversation
- `idx_messages_user_id` on messages(user_id) - User message lookup

---

## Validation Rules

### Task Title
- **Required**: Cannot be empty or whitespace-only
- **Length**: 1-200 characters after trimming
- **Error**: `{"detail": "Title is required and must be 1-200 characters", "code": "INVALID_TITLE"}`

### Task Description
- **Optional**: Can be null or empty string
- **Length**: Maximum 1000 characters
- **Error**: `{"detail": "Description cannot exceed 1000 characters", "code": "DESCRIPTION_TOO_LONG"}`

### Task Priority (Phase II only)
- **Required**: Must be one of: 'low', 'medium', 'high'
- **Default**: 'medium'
- **Error**: `{"detail": "Priority must be low, medium, or high", "code": "INVALID_PRIORITY"}`

### Due Date (Phase II only)
- **Optional**: Can be null
- **Format**: ISO 8601 datetime string
- **Constraint**: Cannot be in the past when creating (warning only on update)
- **Error**: `{"detail": "Due date must be a valid ISO 8601 datetime", "code": "INVALID_DUE_DATE"}`

### Recurrence Rule (Phase II only)
- **Optional**: Can be null
- **Format**: Valid iCal RRULE string
- **Error**: `{"detail": "Recurrence rule must be a valid iCal RRULE", "code": "INVALID_RRULE"}`

### Tag Name
- **Required**: Cannot be empty or whitespace-only
- **Length**: 1-50 characters after trimming
- **Uniqueness**: No duplicate names per user
- **Error**: `{"detail": "Tag name is required and must be 1-50 characters", "code": "INVALID_TAG_NAME"}`

### Task ID (for operations)
- **Required**: Must be a valid integer
- **Existence**: Must correspond to an existing task owned by the user
- **Error**: `{"detail": "Task not found", "code": "TASK_NOT_FOUND"}`

### Chat Message
- **Required**: Cannot be empty or whitespace-only
- **Error**: `{"detail": "Message is required", "code": "INVALID_MESSAGE"}`

### Conversation ID
- **Optional**: Can be null (creates new conversation)
- **Existence**: If provided, must correspond to an existing conversation owned by the user
- **Error**: `{"detail": "Conversation not found", "code": "CONVERSATION_NOT_FOUND"}`

---

## API Design Standards

### Phase II Endpoint Patterns

| Operation       | Method | Path                          | Success Code |
|-----------------|--------|-------------------------------|--------------|
| List resources  | GET    | /api/{user_id}/{resources}    | 200          |
| Get resource    | GET    | /api/{user_id}/{resources}/{id}| 200          |
| Create resource | POST   | /api/{user_id}/{resources}    | 201          |
| Update resource | PUT    | /api/{user_id}/{resources}/{id}| 200          |
| Partial update  | PATCH  | /api/{user_id}/{resources}/{id}| 200          |
| Delete resource | DELETE | /api/{user_id}/{resources}/{id}| 204          |

### Authentication Endpoints

| Operation       | Method | Path                          | Success Code |
|-----------------|--------|-------------------------------|--------------|
| Login           | POST   | /api/v1/auth/login            | 200          |
| Register        | POST   | /api/v1/auth/register         | 201          |
| Refresh token   | POST   | /api/v1/auth/refresh          | 200          |
| Logout          | POST   | /api/v1/auth/logout           | 200          |
| Current user    | GET    | /api/v1/auth/me               | 200          |

### Phase III Chat Endpoint

| Operation       | Method | Path                          | Success Code |
|-----------------|--------|-------------------------------|--------------|
| Send message    | POST   | /api/{user_id}/chat           | 200          |

**Request Schema**:
```json
{
  "message": "<string, required>",
  "conversation_id": "<integer, optional>"
}
```

**Response Schema**:
```json
{
  "conversation_id": "<integer>",
  "response": "<string>",
  "tool_calls": [
    {
      "name": "<tool_name>",
      "arguments": {},
      "result": {}
    }
  ]
}
```

### Query Parameters

- `page`: Page number (default: 1)
- `limit`: Items per page (default: 20, max: 100)
- `sort`: Field to sort by (prefix with - for descending)
- `status`: Filter by status (all, pending, completed)
- `priority`: Filter by priority (low, medium, high)
- `tag`: Filter by tag ID or name
- `q`: Search query string

### Response Pagination Format

```json
{
  "items": [...],
  "total": 150,
  "page": 1,
  "limit": 20,
  "pages": 8
}
```

### Path Parameter Validation Requirements

- All endpoints with `{user_id}` in the path MUST validate that the path parameter matches the JWT user_id
- Validation MUST occur before executing the business logic
- Mismatched user_id values MUST return HTTP 403 Forbidden
- All database queries MUST be scoped using the JWT user_id, NOT the path parameter

---

## Success Criteria

### Phase II Completion (COMPLETED)

#### Functional Requirements
- [x] **User Auth**: Better Auth integration works with JWT plugin for user registration, login, logout, and token refresh
- [x] **Task CRUD**: All basic task operations work correctly with new API pattern
- [x] **Data Isolation**: Users only see their own tasks and tags; path parameter validation prevents cross-user access
- [x] **Priorities**: Tasks can be assigned and filtered by priority
- [x] **Tags**: Users can create, edit, delete, and assign tags
- [x] **Search**: Full-text search returns relevant results
- [x] **Filter/Sort**: All filter and sort combinations work
- [x] **Due Dates**: Tasks display due date indicators correctly
- [x] **Notifications**: Browser notifications trigger for due tasks (P3)
- [x] **Recurring Tasks**: RRULE parsing and next occurrence calculation (P3)
- [x] **API Migration**: All user-specific endpoints migrated to `/api/{user_id}/{resources}` pattern with proper validation

#### Technical Requirements
- [x] **AI-Generated Code**: All code generated from specs with exceptions documented
- [x] **Backend Tests**: pytest coverage >= 80% on core logic (verified in nightly pipeline)
- [x] **Frontend Tests**: Component test coverage >= 70% (verified in nightly pipeline)
- [x] **CI Pipeline**: All PR checks pass (lint, test, build) on every PR
- [x] **Docker**: Both services run via `docker-compose up`
- [x] **API Docs**: OpenAPI documentation accurate and complete
- [x] **JWT Security**: Better Auth JWT validation works correctly with shared secret
- [x] **Path Validation**: All endpoints with user_id in path validate against JWT user_id
- [x] **API Client**: API client implemented at `@/lib/api-client` with Better Auth integration
- [x] **Multi-User Isolation**: Tests verify that users can't access other users' resources
- [x] **Performance**: Lighthouse score >= 90 (verified in nightly pipeline)

### Phase III Completion (ACTIVE)

#### Functional Requirements
- [ ] **Chat Interface**: OpenAI ChatKit-based UI allows sending messages and receiving AI responses
- [ ] **Conversation Persistence**: Conversations and messages are stored in database
- [ ] **MCP Tools**: All 5 MCP tools (add_task, list_tasks, complete_task, delete_task, update_task) work correctly
- [ ] **Natural Language**: AI understands natural language commands for task management
- [ ] **Tool Invocation**: Agent correctly invokes appropriate MCP tools based on user intent
- [ ] **Conversation Resume**: Users can continue previous conversations
- [ ] **Stateless Server**: Server holds no in-memory state; all state in database
- [ ] **Better Auth Integration**: User authentication works with Phase III frontend

#### Technical Requirements
- [ ] **Phase Separation**: Zero imports from Phase II codebase
- [ ] **MCP SDK**: Official MCP SDK used correctly
- [ ] **OpenAI Agents SDK**: Agent configured with proper system prompt and tools
- [ ] **Separate Tables**: Phase III uses `tasks_phaseiii`, `conversations`, `messages` tables
- [ ] **Backend Tests**: pytest coverage >= 80% on MCP tools and chat service
- [ ] **Frontend Tests**: Component tests for chat interface
- [ ] **UV Package Manager**: Backend uses UV for dependency management
- [ ] **Bun Package Manager**: Frontend uses Bun for dependency management
- [ ] **OpenAI ChatKit**: Frontend built with ChatKit starter template
- [ ] **API Docs**: Chat endpoint documented in OpenAPI

### Documentation Requirements (Phase III)

- [ ] Specs exist for all features in `/specs/sphaseIII/NNN-feature-name/spec.md`
- [ ] Implementation plans exist in `/specs/sphaseIII/NNN-feature-name/plan.md`
- [ ] Task breakdowns exist in `/specs/sphaseIII/NNN-feature-name/tasks.md`
- [ ] README.md includes setup, development, and deployment instructions
- [ ] DEVIATIONS.md documents any manual code (if any)

---

### Phase IV Completion (ACTIVE)

#### Functional Requirements
- [ ] **Four Services Deployed**: Frontend, Backend, MCP Server, Redis all running in Kubernetes
- [ ] **Ingress Routing**: Nginx Ingress routes / to frontend and /api to backend at todo-app.local
- [ ] **Horizontal Pod Autoscaling**: HPA scales frontend and backend based on CPU/memory metrics
- [ ] **Redis Persistence**: Redis data persists across pod restarts via PersistentVolume
- [ ] **Complete User Flow**: End-to-end user journey works (auth → chat → task operations via MCP tools)
- [ ] **All 5 MCP Tools Working**: add_task, list_tasks, complete_task, delete_task, update_task functional in Kubernetes
- [ ] **Namespace Isolation**: All resources deployed in todo-phaseiv namespace
- [ ] **External Database**: Backend connects to shared Neon PostgreSQL instance
- [ ] **Service Discovery**: Services communicate via Kubernetes internal DNS (ClusterIP)
- [ ] **Load Balancing**: Multiple frontend/backend replicas load-balanced automatically

#### Technical Requirements
- [ ] **Comprehensive Spec**: `/specs/sphaseIV/001-kubernetes-deployment/spec.md` exists and complete
- [ ] **Helm Chart Best Practices**: Chart follows Helm conventions, passes helm lint with zero warnings
- [ ] **Resource Limits**: CPU/memory requests and limits defined for all containers
- [ ] **Health Probes**: Liveness and readiness probes configured for all services
- [ ] **Secrets Management**: Database credentials, API keys stored in Kubernetes Secrets
- [ ] **ConfigMaps**: Non-sensitive configuration externalized in ConfigMaps
- [ ] **helm test Passes**: Helm test suite validates deployment correctness
- [ ] **Incremental Rollout**: Deployment script follows Redis → MCP → Backend → Frontend → Ingress order
- [ ] **Rollback Strategy**: helm rollback tested and functional
- [ ] **Values Templating**: Environment-specific values templated in values.yaml

#### Documentation Requirements (Phase IV)
- [ ] **KUBERNETES_GUIDE.md**: Comprehensive guide covering Minikube setup, Helm installation, deployment steps, testing procedures
- [ ] **Helm README.md**: Chart-specific README in `/phaseIV/kubernetes/helm/todo-app/README.md`
- [ ] **RUNBOOK.md**: Operational runbook covering common tasks (scale replicas, view logs, restart pods, troubleshoot Ingress)
- [ ] **Architecture Diagram**: Visual diagram of Kubernetes architecture (services, ingress, PVCs)
- [ ] **Deployment Scripts**: Automated scripts in `/phaseIV/kubernetes/scripts/` (setup-minikube.sh, deploy.sh, test.sh)

#### Testing Requirements
- [ ] **E2E Test**: End-to-end test covers full user flow (login → chat → task CRUD → verify persistence)
- [ ] **Load Test**: Load test triggers HPA scaling (verify replicas scale from 2 to 5 under load)
- [ ] **Resilience Test**: Pod deletion test (kubectl delete pod) validates automatic restart and service continuity
- [ ] **Persistence Test**: Redis pod restart test validates data retention via PVC
- [ ] **Ingress Test**: HTTP requests to todo-app.local validate correct routing (/ → frontend, /api → backend)
- [ ] **helm test**: Helm-provided tests validate deployment health
- [ ] **Resource Monitoring**: kubectl top pods shows resource usage; metrics-server functional

---

## Constraints (Hard Limits)

### Development Constraints
- **No Manual Coding**: AI agent generates all implementation (see Principle I for exception)
- **Spec First**: No implementation without corresponding specification
- **Version Control**: All changes via pull requests to main

### Technology Constraints

**Phase II**:
- **Frontend**: Next.js 16 App Router, TypeScript, bun only
- **Backend**: Python 3.11+, FastAPI, uv only
- **Database**: PostgreSQL (Neon Serverless) only
- **ORM**: SQLModel only (no raw SQLAlchemy)
- **Authentication**: Better Auth with JWT plugin for frontend authentication
- **API Endpoint Format**: All user-specific endpoints MUST follow the `/api/{user_id}/{resources}` pattern
- **API Client Location**: MUST be implemented at `@/lib/api-client` with Better Auth integration

**Phase III** (MANDATORY per hackathon requirements):
- **Frontend**: OpenAI ChatKit (https://platform.openai.com/docs/guides/chatkit)
- **Backend**: Python FastAPI
- **AI Framework**: OpenAI Agents SDK (https://github.com/openai/openai-agents-python)
- **MCP Server**: Official MCP SDK (https://github.com/modelcontextprotocol/python-sdk)
- **ORM**: SQLModel
- **Database**: Neon Serverless PostgreSQL (same instance, different tables)
- **Authentication**: Better Auth
- **Backend Package Manager**: UV (`uv add <package>`)
- **Frontend Package Manager**: Bun (`bun add <package>`)

**Phase IV** (MANDATORY per hackathon requirements):
- **Container Runtime**: Docker Desktop only
- **Orchestration**: Kubernetes via Minikube only
- **Package Manager**: Helm Charts v3.13+ only
- **Ingress Controller**: Nginx Ingress only
- **Storage**: PersistentVolume with standard StorageClass
- **Autoscaling**: Horizontal Pod Autoscaler with metrics-server
- **Cluster Requirements**: Minikube with 4 CPU, 8GB RAM minimum
- **Namespace**: todo-phaseiv (MUST use this namespace)
- **Database**: Neon Serverless PostgreSQL (shared with Phase III)
- **Optional AI DevOps Tools**: kubectl-ai, kagent, Docker AI (Gordon)

### Security Constraints
- **No Secrets in Code**: All secrets via environment variables
- **Token Management**: Better Auth handles token storage and refresh
- **Data Access**: All queries scoped to authenticated user JWT user_id (NOT path parameter)
- **Path Parameter Validation**: User ID in path must match JWT user_id; mismatch returns 403 Forbidden
- **Token Validation**: Backend validates Better Auth JWTs using shared secret
- **Data Isolation**: Path parameter user_id is NOT authoritative for data access decisions

### Performance Constraints
- **API Response Time**: p95 < 200ms for CRUD operations
- **Frontend TTI**: Time to Interactive < 3 seconds
- **Database Queries**: No N+1 queries (use eager loading)
- **Chat Response Time**: p95 < 5s for AI responses (includes OpenAI API latency)

### Phase Separation Constraints
- **No Imports Between Phases**: Phase III MUST NOT import from phaseII or phaseI
- **Independent Implementations**: Each phase reimplements required functionality
- **Separate Database Tables**: Phase III uses `tasks_phaseiii` table, not Phase II `tasks` table
- **Independent Migrations**: Phase III has its own Alembic migration history

---

## Governance & Enforcement

### Authority
This constitution is the **single source of truth** for all phases of development. All decisions, specifications, implementations, and reviews MUST align with these principles.

### Amendment Process
Amendments require:
1. Written justification explaining why the change is necessary
2. Impact analysis on existing specifications and implementations
3. Team review and approval
4. Update to version number and "Last Amended" date
5. Sync Impact Report update in HTML comment

### Deviation Policy
Any deviation from this constitution MUST be:
1. **Documented**: Noted in `DEVIATIONS.md` with full justification
2. **Justified**: Explained as necessary to meet requirements or overcome AI limitations
3. **Minimal**: The smallest possible deviation to achieve the goal
4. **Reviewed**: Approved before merging

### Compliance Verification
- All pull requests MUST be reviewed for constitutional compliance
- CI checks MUST pass before merge
- Code reviews verify adherence to principles
- Spec references required in PR descriptions

---

## Philosophical Foundation

**Spec-Driven Development Principle**:
> "The engineer is no longer a syntax writer but a system architect. The specification is the blueprint; AI is the builder."

**Evolution Mindset**:
> "Each phase builds on lessons learned. We evolve from CLI to web to AI while maintaining the discipline of specification-first development."

**Security-First Thinking**:
> "Security is not an afterthought. Every feature considers authentication, authorization, and data isolation from the specification phase."

**Quality Over Speed**:
> "Take time to write precise specifications. The better your spec, the better the AI's implementation. Iteration on specs is encouraged; manual coding is forbidden."

**Phase Independence**:
> "Each phase stands alone. Complete separation ensures clean architecture and demonstrates multiple approaches to the same problem domain."

---

## Requirement-to-Rule Mapping

### Phase II Requirements

| Req ID | Requirement Description                            | Constitutional Rule(s)                     | Section      |
|--------|---------------------------------------------------|--------------------------------------------|--------------|
| FR-001 | Multi-user authentication                          | JWT token flow, Better Auth integration    | IV           |
| FR-002 | Persistent task storage                            | Neon PostgreSQL, SQLModel                  | III          |
| FR-003 | Task CRUD operations                               | Feature Scope P1                           | X            |
| FR-004 | Priority assignment                                | Data Model - Task.priority                 | Data Model   |
| FR-005 | Tag management                                     | Data Model - Tag entity                    | Data Model   |
| FR-006 | Search and filter                                  | Feature Scope P2                           | X            |
| FR-007 | Due dates and reminders                            | Feature Scope P3                           | X            |
| FR-008 | Recurring tasks                                    | Data Model - Task.recurrence_rule          | Data Model   |
| QR-001 | API response time < 200ms p95                      | Performance Constraints                    | Constraints  |
| QR-002 | Frontend TTI < 3s                                  | Performance Constraints                    | Constraints  |
| QR-003 | Lighthouse score >= 90                             | Nightly Pipeline Performance Audit         | IX           |
| SR-001 | Monorepo structure                                 | Full-Stack Monorepo Architecture           | II           |
| SR-002 | API versioning                                     | Backend Architecture Standards             | V            |
| SR-003 | Component organization                             | Frontend Architecture Standards            | VI           |
| IR-001 | REST API design                                    | API Design Standards                       | API Design   |
| IR-002 | JWT token format                                   | JWT Security principle                     | IV           |
| PR-001 | Spec-driven workflow                               | Spec-Driven Development                    | I            |
| PR-002 | CI/CD pipeline                                     | CI/CD Pipeline                             | IX           |
| PR-003 | Docker deployment                                  | Containerization & Deployment              | VIII         |
| SEC-001| Secure token storage                               | JWT Security - Storage requirements        | IV           |
| SEC-002| Data isolation                                     | JWT Security - Data scoping                | IV           |
| SEC-003| CORS policy                                        | Backend Architecture Standards             | V            |
| SEC-004| Path parameter user ID validation                  | JWT Security - Path Parameter Matching     | IV           |

### Phase III Requirements

| Req ID      | Requirement Description                       | Constitutional Rule(s)                     | Section      |
|-------------|----------------------------------------------|--------------------------------------------|--------------|
| FR-P3-001   | Conversational chat interface                 | OpenAI ChatKit Integration                 | VI           |
| FR-P3-002   | Natural language task management              | Agent Behavior Specification               | XII          |
| FR-P3-003   | MCP tools for task operations                 | MCP Server Architecture                    | XI           |
| FR-P3-004   | Stateless chat endpoint                       | Conversational AI Standards                | XIII         |
| FR-P3-005   | Conversation persistence                      | Data Model - Conversation, Message         | Data Model   |
| FR-P3-006   | Tool invocation by AI agent                   | OpenAI Agents SDK Integration              | XII          |
| FR-P3-007   | Chat history context                          | Conversation Flow specification            | XIII         |
| FR-P3-008   | Error handling in conversations               | Agent Behavior - Error Handling            | XII          |
| QR-P3-001   | Chat response time < 5s p95                   | Performance Constraints                    | Constraints  |
| SR-P3-001   | Phase III directory structure                 | Repository Structure                       | II           |
| SR-P3-002   | Complete phase separation                     | Phase Separation Constraints               | Constraints  |
| IR-P3-001   | Chat API endpoint                             | API Design Standards - Phase III           | API Design   |
| IR-P3-002   | MCP tool interface                            | MCP Tools Specification                    | XI           |
| TC-P3-001   | OpenAI ChatKit frontend                       | Technology Constraints - Phase III         | Constraints  |
| TC-P3-002   | OpenAI Agents SDK                             | Technology Constraints - Phase III         | Constraints  |
| TC-P3-003   | Official MCP SDK                              | Technology Constraints - Phase III         | Constraints  |
| TC-P3-004   | UV package manager for backend                | Technology Constraints - Phase III         | Constraints  |
| TC-P3-005   | Bun package manager for frontend              | Technology Constraints - Phase III         | Constraints  |

### Phase IV Requirements

| Req ID      | Requirement Description                       | Constitutional Rule(s)                     | Section      |
|-------------|----------------------------------------------|--------------------------------------------|--------------|
| FR-P4-001   | Four services deployed in Kubernetes          | Containerization & Orchestration           | XIV          |
| FR-P4-002   | Nginx Ingress routing                         | Production-Grade Deployment - Ingress      | XV           |
| FR-P4-003   | Horizontal Pod Autoscaling                    | Production-Grade Deployment - HPA          | XV           |
| FR-P4-004   | Redis persistence via PersistentVolume        | Production-Grade Deployment - PV           | XV           |
| FR-P4-005   | Complete user flow in Kubernetes              | Success Criteria - Functional              | Success      |
| FR-P4-006   | All 5 MCP tools functional                    | Success Criteria - Functional              | Success      |
| FR-P4-007   | Namespace isolation (todo-phaseiv)            | Containerization & Orchestration           | XIV          |
| FR-P4-008   | External Neon PostgreSQL connection           | Success Criteria - Functional              | Success      |
| FR-P4-009   | Service discovery via ClusterIP               | Containerization & Orchestration           | XIV          |
| FR-P4-010   | Load balancing across replicas                | Success Criteria - Functional              | Success      |
| SR-P4-001   | Phase IV directory structure                  | Repository Structure                       | II           |
| SR-P4-002   | Helm chart best practices                     | Containerization & Orchestration           | XIV          |
| SR-P4-003   | Infrastructure as Code principles             | Containerization & Orchestration           | XIV          |
| SR-P4-004   | Container artifact reuse exception            | Phase IV Exception for Container Reuse     | II           |
| TC-P4-001   | Docker Desktop container runtime              | Technology Constraints - Phase IV          | Constraints  |
| TC-P4-002   | Kubernetes via Minikube                       | Technology Constraints - Phase IV          | Constraints  |
| TC-P4-003   | Helm Charts v3.13+                            | Technology Constraints - Phase IV          | Constraints  |
| TC-P4-004   | Nginx Ingress Controller                      | Technology Constraints - Phase IV          | Constraints  |

---

## Constitutional Self-Checks

### 1. Alignment Check
**Status**: PASS
- All 50+ rules map to documented requirements
- No orphan rules without requirement backing
- Requirement-to-Rule mapping table complete for Phase II, Phase III, and Phase IV
- New Phase IV requirements added (FR-P4-001 through FR-P4-010, SR-P4-001 through SR-P4-004, TC-P4-001 through TC-P4-004)

### 2. Coverage Check
**Status**: PASS
- Functional Requirements: Covered (FR-001 through FR-008, FR-P3-001 through FR-P3-008, FR-P4-001 through FR-P4-010)
- Quality Requirements: Covered (QR-001 through QR-003, QR-P3-001)
- Structural Requirements: Covered (SR-001 through SR-003, SR-P3-001, SR-P3-002, SR-P4-001 through SR-P4-004)
- Interface Requirements: Covered (IR-001, IR-002, IR-P3-001, IR-P3-002)
- Process Requirements: Covered (PR-001 through PR-003)
- Security Requirements: Covered (SEC-001 through SEC-004)
- Technology Constraints: Covered (TC-P3-001 through TC-P3-005, TC-P4-001 through TC-P4-004)

### 3. Conflict Check
**Status**: PASS
- No contradictory rules identified
- Phase II, Phase III, and Phase IV rules are complementary, not conflicting
- Phase separation rules prevent cross-phase conflicts
- Phase IV container artifact reuse exception explicitly documented and justified
- Technology stack consistent within each phase

### 4. Completeness Check
**Status**: PASS
- All Phase II features have governance rules (COMPLETED)
- All Phase III features have governance rules (COMPLETED)
- All Phase IV features have governance rules (ACTIVE)
- Containerization & Orchestration principles fully specified (Principle XIV)
- Production-Grade Deployment principles fully specified (Principle XV)
- Phase IV workflow guidance integrated into Principle I
- Kubernetes architecture, Helm charts, production features all covered
- Testing requirements comprehensive (E2E, load, resilience, persistence, ingress)
- Documentation requirements specified (KUBERNETES_GUIDE.md, RUNBOOK.md)

---

**Version**: 2.5.0 | **Ratified**: 2025-12-04 | **Last Amended**: 2025-12-25
